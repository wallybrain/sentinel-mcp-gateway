---
phase: 02-mcp-protocol-layer
plan: 02
type: execute
wave: 2
depends_on: [02-01]
files_modified:
  - src/catalog/mod.rs
  - src/gateway.rs
  - src/lib.rs
  - src/main.rs
  - tests/catalog_test.rs
  - tests/gateway_integration_test.rs
autonomous: true
requirements: [PROTO-02, PROTO-03, PROTO-06]

must_haves:
  truths:
    - "The gateway aggregates tools from multiple stub backends into a single unified catalog"
    - "tools/list returns all tools from all backends in one response"
    - "Tool name collisions are resolved by prefixing with backend name"
    - "The catalog tracks which backend owns each tool for future routing"
    - "A full MCP session works end-to-end: initialize -> initialized -> tools/list -> ping"
    - "Requests before initialize return error -32002"
    - "Notifications (no id) do not receive responses"
  artifacts:
    - path: "src/catalog/mod.rs"
      provides: "ToolCatalog struct aggregating tools from multiple backends"
      min_lines: 40
      contains: "ToolCatalog"
    - path: "src/gateway.rs"
      provides: "Central dispatch loop wiring transport, state machine, and catalog"
      min_lines: 80
      contains: "dispatch"
    - path: "tests/gateway_integration_test.rs"
      provides: "End-to-end test piping JSON-RPC through the dispatch loop"
      min_lines: 60
  key_links:
    - from: "src/gateway.rs"
      to: "src/protocol/mcp.rs"
      via: "McpState and handle_initialize"
      pattern: "McpState|handle_initialize"
    - from: "src/gateway.rs"
      to: "src/catalog/mod.rs"
      via: "catalog.all_tools()"
      pattern: "all_tools"
    - from: "src/gateway.rs"
      to: "src/protocol/jsonrpc.rs"
      via: "JsonRpcRequest, JsonRpcResponse parsing and serialization"
      pattern: "JsonRpcRequest|JsonRpcResponse"
    - from: "src/main.rs"
      to: "src/gateway.rs"
      via: "Spawns transport tasks and dispatch loop"
      pattern: "tokio::spawn|stdio_reader|stdio_writer"
---

<objective>
Build the tool catalog aggregation and central dispatch loop, then wire everything into main.rs for a working MCP server that handles initialize, tools/list, and ping over stdio.

Purpose: Completes Phase 2 -- the gateway is a functional MCP server that Claude Code could connect to (though with stub tools only). This proves the full message flow: stdin -> parse -> state gate -> dispatch -> serialize -> stdout.
Output: Working binary that speaks MCP over stdio, with integration tests proving end-to-end correctness.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-mcp-protocol-layer/2-RESEARCH.md
@.planning/phases/02-mcp-protocol-layer/02-01-SUMMARY.md
@src/protocol/jsonrpc.rs
@src/protocol/mcp.rs
@src/transport/stdio.rs
@src/lib.rs
@Cargo.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Tool catalog and dispatch loop</name>
  <files>
    src/catalog/mod.rs
    src/gateway.rs
    src/lib.rs
    src/main.rs
  </files>
  <action>
**1. Create `src/catalog/mod.rs`:**

`ToolCatalog` struct with a `HashMap<String, (rmcp::model::Tool, String)>` mapping tool_name -> (tool_definition, backend_name).

Methods:
- `pub fn new() -> Self`
- `pub fn register_backend(&mut self, backend_name: &str, tools: Vec<rmcp::model::Tool>)` -- inserts each tool. On name collision, prefix with `{backend_name}__{tool_name}` and log a warning.
- `pub fn all_tools(&self) -> Vec<rmcp::model::Tool>` -- returns all tool definitions (cloned).
- `pub fn route(&self, tool_name: &str) -> Option<&str>` -- returns the backend name owning a tool.
- `pub fn tool_count(&self) -> usize`

Add a helper function to create stub tools for testing:
```rust
pub fn create_stub_catalog() -> ToolCatalog
```
This creates a catalog with 2 stub backends:
- "stub-n8n" backend with tools: "list_workflows" (description: "List n8n workflows"), "execute_workflow" (description: "Execute an n8n workflow")
- "stub-sqlite" backend with tools: "read_query" (description: "Execute a read-only SQL query"), "write_query" (description: "Execute a write SQL query")

Each tool needs a valid `inputSchema` (use a minimal JSON Schema object: `{"type": "object", "properties": {}}` serialized into `serde_json::Value`). Check rmcp `Tool` struct fields -- it likely has `name`, `description`, and `input_schema`. Construct using the struct directly or via a builder if available. Handle `Cow<'static, str>` by using `.into()` on String values.

**2. Create `src/gateway.rs`:**

The central dispatch loop:
```rust
pub async fn run_dispatch(
    mut rx: mpsc::Receiver<String>,
    tx: mpsc::Sender<String>,
    catalog: &ToolCatalog,
) -> anyhow::Result<()>
```

Logic:
1. Start in `McpState::Created`
2. Loop: receive line from `rx`
3. Parse line as `JsonRpcRequest`. On parse error, send JSON-RPC error response (code PARSE_ERROR, id Null). Continue.
4. Check `state.can_accept_method(&request.method)`. If rejected and request has an id, send error response (code -32002, message "Server not initialized"). If notification (no id), silently drop. Continue.
5. Match on `request.method`:
   - `"initialize"`: Call `handle_initialize(params)`. On Ok, wrap in `JsonRpcResponse::success`. On Err, wrap in `JsonRpcResponse::error`. Send response. Transition state to `Initializing`.
   - `"notifications/initialized"`: Transition state to `Operational`. Do NOT send a response (it's a notification).
   - `"tools/list"`: Build `ListToolsResult` from `catalog.all_tools()`. Use `rmcp::model::ListToolsResult`. Serialize to Value. Send as success response.
   - `"ping"`: Send success response with `json!({})` as result.
   - Any other method: Send error response (code METHOD_NOT_FOUND, message "Method not found: {method}").
6. When rx channel closes (recv returns None), set state to Closed and return Ok.

IMPORTANT: Only send responses for requests (those with an `id`). Never send responses for notifications.

IMPORTANT: Serialize responses via `serde_json::to_string` and send through `tx` channel. The writer task handles stdout and newline framing.

**3. Update `src/lib.rs`:**
Add `pub mod catalog;` and `pub mod gateway;`

**4. Update `src/main.rs`:**
Replace the current placeholder main with:
1. Load config (existing CLI + config loading)
2. Build the stub tool catalog via `create_stub_catalog()`
3. Create two bounded mpsc channels: `inbound` (reader -> dispatch, capacity 64) and `outbound` (dispatch -> writer, capacity 64)
4. Spawn `stdio_reader(inbound_tx)` as a tokio task
5. Spawn `stdio_writer(outbound_rx)` as a tokio task
6. Run `run_dispatch(inbound_rx, outbound_tx, &catalog).await`
7. Log at info level when dispatch loop ends (stdin closed)

The config loading should NOT fail if env vars for JWT/Postgres are missing (those aren't needed yet). Either: skip secret resolution in main.rs for now, or wrap in a try and log a warning. The gateway should start and serve MCP even without auth/postgres configured. If the current main.rs calls resolve_jwt_secret or resolve_url, guard those behind a flag or move them to later phases.

Verify with `cargo build --release` -- 0 errors, 0 warnings.
  </action>
  <verify>
`cargo build --release` succeeds with 0 errors and 0 warnings. `cargo clippy` clean.
  </verify>
  <done>
ToolCatalog aggregates tools from multiple backends with collision handling. Dispatch loop handles initialize/initialized/tools-list/ping with correct state gating. main.rs wires transport, dispatch, and catalog into a running binary.
  </done>
</task>

<task type="auto">
  <name>Task 2: Catalog unit tests and end-to-end integration test</name>
  <files>
    tests/catalog_test.rs
    tests/gateway_integration_test.rs
  </files>
  <action>
**1. Create `tests/catalog_test.rs`:**

5 tests:
1. `test_register_and_list_tools` -- Register 2 backends with 2 tools each. `all_tools()` returns 4 tools. `tool_count()` == 4.
2. `test_route_returns_correct_backend` -- Register tools, verify `route("list_workflows")` returns `Some("stub-n8n")` and `route("read_query")` returns `Some("stub-sqlite")`.
3. `test_route_unknown_tool_returns_none` -- `route("nonexistent")` returns None.
4. `test_name_collision_prefixes` -- Register two backends both having a tool named "query". Verify both tools exist (one as "query", one as "{backend}__query"). `tool_count()` == 2.
5. `test_stub_catalog_has_expected_tools` -- `create_stub_catalog()` has 4 tools. Route each to correct backend.

**2. Create `tests/gateway_integration_test.rs`:**

End-to-end tests that create channels, feed JSON-RPC messages through `run_dispatch`, and assert responses. Use `tokio::sync::mpsc::channel(64)` to simulate the transport layer without actual stdin/stdout.

Helper function:
```rust
async fn send_and_receive(
    tx: &mpsc::Sender<String>,
    rx: &mut mpsc::Receiver<String>,
    message: &str,
) -> String {
    tx.send(message.to_string()).await.unwrap();
    // Small delay to let dispatch process
    tokio::time::sleep(std::time::Duration::from_millis(50)).await;
    rx.try_recv().unwrap()
}
```

Or better: spawn dispatch in a task, send messages, receive responses with a timeout.

6 tests:

1. `test_full_mcp_session` -- Send initialize request -> verify response has protocolVersion "2025-03-26" and capabilities.tools. Send initialized notification -> verify NO response. Send tools/list -> verify response has tools array with 4 stub tools. Send ping -> verify response has empty result object.

2. `test_request_before_initialize_returns_error` -- Send tools/list before initialize. Verify error response with code -32002.

3. `test_parse_error_returns_error` -- Send "not json at all". Verify error response with code -32700 (PARSE_ERROR).

4. `test_unknown_method_returns_error` -- Complete initialize handshake, then send request with method "foo/bar". Verify error response with code -32601 (METHOD_NOT_FOUND).

5. `test_notification_gets_no_response` -- Send initialized notification in Created state (should be rejected but since it's a notification, no response). Verify no message appears on response channel within 100ms timeout.

6. `test_ping_works_before_initialize` -- Send ping in Created state. Verify success response with empty result.

For each test:
- Create fresh channels and catalog
- Spawn `run_dispatch` as a tokio task
- Send messages via the inbound channel
- Read responses from the outbound channel
- Drop the inbound sender to close the dispatch loop when done

Run `cargo test` -- all tests must pass. Expected total: 19 (Phase 1) + 11 (02-01) + 5 (catalog) + 6 (gateway) = 41 tests.
  </action>
  <verify>
`cargo test` passes all tests with 0 failures. At least 11 new tests (5 catalog + 6 gateway integration). Total test count is approximately 41.
  </verify>
  <done>
Tool catalog correctly aggregates, routes, and handles collisions (5 tests). Full MCP session works end-to-end through dispatch loop: initialize -> initialized -> tools/list -> ping (6 tests). Pre-initialization requests are rejected. Parse errors return -32700. Unknown methods return -32601. Notifications receive no response.
  </done>
</task>

</tasks>

<verification>
- `cargo build --release` compiles with 0 errors, 0 warnings
- `cargo test` passes all ~41 tests
- `cargo clippy` produces no warnings
- Binary can be tested manually: `echo '{"jsonrpc":"2.0","id":1,"method":"initialize","params":{"protocolVersion":"2025-03-26","capabilities":{},"clientInfo":{"name":"test","version":"1.0"}}}' | cargo run -- --config sentinel.toml 2>/dev/null` returns a valid initialize response on stdout
- tools/list returns 4 stub tools when queried after initialization
- No `println!` calls in src/ (stdout reserved for JSON-RPC)
</verification>

<success_criteria>
- ToolCatalog aggregates tools from multiple backends with collision resolution
- Dispatch loop handles the complete MCP lifecycle (Created -> Initializing -> Operational)
- Full end-to-end test proves initialize + tools/list + ping work over channel-simulated stdio
- Binary is a working MCP server (stub tools only -- real backends come in Phase 3)
- ~41 total tests passing
</success_criteria>

<output>
After completion, create `.planning/phases/02-mcp-protocol-layer/02-02-SUMMARY.md`
</output>
