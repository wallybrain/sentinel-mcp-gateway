---
phase: 05-audit-logging
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Cargo.toml
  - src/lib.rs
  - src/audit/mod.rs
  - src/audit/db.rs
  - src/audit/writer.rs
  - migrations/001_create_audit_log.sql
autonomous: true
requirements: [AUDIT-03, DEPLOY-04]

must_haves:
  truths:
    - "sqlx PgPool connects to Postgres and runs embedded migrations at startup"
    - "AuditEntry struct captures all required fields (request_id, timestamp, client, tool, backend, args, status, latency)"
    - "Background writer task drains bounded mpsc channel and inserts rows without blocking callers"
    - "Audit writer logs errors but never panics on Postgres failure"
  artifacts:
    - path: "src/audit/mod.rs"
      provides: "Module re-exports for AuditEntry, create_pool, run_migrations, audit_writer"
    - path: "src/audit/db.rs"
      provides: "PgPool creation, migration runner, insert_audit_entry function"
      contains: "create_pool"
    - path: "src/audit/writer.rs"
      provides: "Background channel consumer that writes AuditEntry to Postgres"
      contains: "audit_writer"
    - path: "migrations/001_create_audit_log.sql"
      provides: "audit_log table schema with indexes"
      contains: "CREATE TABLE"
    - path: "Cargo.toml"
      provides: "sqlx, uuid, chrono dependencies"
      contains: "sqlx"
  key_links:
    - from: "src/audit/writer.rs"
      to: "src/audit/db.rs"
      via: "insert_audit_entry called in writer loop"
      pattern: "insert_audit_entry"
    - from: "src/audit/db.rs"
      to: "migrations/"
      via: "sqlx::migrate! macro embeds SQL files"
      pattern: "migrate!"
---

<objective>
Create the audit logging module with Postgres connection pool, embedded migrations, AuditEntry struct, and async background writer task.

Purpose: Establishes the audit infrastructure so that the dispatch loop (Plan 02) can fire-and-forget audit entries via a bounded channel without blocking tool call responses.
Output: `src/audit/` module with db.rs and writer.rs, migration SQL, and updated Cargo.toml dependencies.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-audit-logging/05-RESEARCH.md
@Cargo.toml
@src/lib.rs
@src/config/types.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add dependencies and create audit module with PgPool, migrations, and AuditEntry</name>
  <files>
    Cargo.toml
    src/lib.rs
    src/audit/mod.rs
    src/audit/db.rs
    migrations/001_create_audit_log.sql
  </files>
  <action>
Add to Cargo.toml [dependencies]:
```toml
sqlx = { version = "0.8", features = ["runtime-tokio", "postgres", "migrate", "chrono", "uuid"] }
uuid = { version = "1", features = ["v4"] }
chrono = { version = "0.4", features = ["serde"] }
```

Add `pub mod audit;` to src/lib.rs.

Create `migrations/001_create_audit_log.sql` with the schema from research:
- `audit_log` table with columns: id (BIGSERIAL PK), request_id (UUID NOT NULL), timestamp (TIMESTAMPTZ NOT NULL DEFAULT NOW()), client_subject (TEXT NOT NULL), client_role (TEXT NOT NULL), tool_name (TEXT NOT NULL), backend_name (TEXT NOT NULL), request_args (JSONB nullable), response_status (TEXT NOT NULL), error_message (TEXT nullable), latency_ms (BIGINT NOT NULL), created_at (TIMESTAMPTZ NOT NULL DEFAULT NOW())
- Indexes on: timestamp, request_id, client_subject, tool_name

Create `src/audit/mod.rs` with pub mod declarations and re-exports.

Create `src/audit/db.rs` with:
- `AuditEntry` struct (all fields from research: request_id, timestamp, client_subject, client_role, tool_name, backend_name, request_args, response_status, error_message, latency_ms)
- `create_pool(url: &str, max_connections: u32) -> Result<sqlx::PgPool, sqlx::Error>` using PgPoolOptions with acquire_timeout of 5 seconds
- `run_migrations(pool: &sqlx::PgPool) -> Result<(), sqlx::Error>` using `sqlx::migrate!("./migrations")`
- `insert_audit_entry(pool: &sqlx::PgPool, entry: &AuditEntry) -> Result<(), sqlx::Error>` using runtime `sqlx::query()` with `.bind()` (NOT compile-time query macro -- avoids DATABASE_URL requirement at build time)

Use `uuid::Uuid`, `chrono::DateTime<chrono::Utc>`, `serde_json::Value` for field types.
  </action>
  <verify>
`cargo build --release 2>&1` compiles with no errors. The `migrations/` directory contains the SQL file. The audit module is accessible via `sentinel_gateway::audit`.
  </verify>
  <done>Cargo.toml has sqlx/uuid/chrono deps, audit module compiles, migration SQL file exists with correct schema, AuditEntry struct has all required fields, create_pool/run_migrations/insert_audit_entry functions compile.</done>
</task>

<task type="auto">
  <name>Task 2: Create async audit writer background task</name>
  <files>
    src/audit/writer.rs
    src/audit/mod.rs
  </files>
  <action>
Create `src/audit/writer.rs` with:
- `pub async fn audit_writer(pool: sqlx::PgPool, mut rx: tokio::sync::mpsc::Receiver<AuditEntry>)` that:
  - Loops on `rx.recv().await`
  - Calls `insert_audit_entry(&pool, &entry).await`
  - On insert error: logs via `tracing::error!` but NEVER panics (audit is best-effort)
  - When rx closes (returns None), drains any remaining buffered entries before exiting (for graceful shutdown in Phase 7)
  - Logs "Audit writer shutting down" on exit

Update `src/audit/mod.rs` to add `pub mod writer;` and re-export `writer::audit_writer`.

Key design decisions per research:
- Channel consumer pattern (not inline awaits in dispatch)
- Errors are logged, never propagated or panicked
- Writer drains remaining entries on channel close (future-proofing for HEALTH-05 graceful shutdown)
  </action>
  <verify>
`cargo build --release 2>&1` compiles with no errors. `cargo test 2>&1` passes all existing tests (no regressions). Grep src/audit/writer.rs for `tracing::error` to confirm error handling exists. Grep for `panic` to confirm none exists.
  </verify>
  <done>audit_writer function compiles, handles errors gracefully (log-only, no panic), drains remaining entries on channel close, all 85 existing tests still pass.</done>
</task>

</tasks>

<verification>
- `cargo build --release` compiles cleanly with new sqlx/uuid/chrono dependencies
- `cargo test` passes all existing tests (85)
- `src/audit/` module exists with mod.rs, db.rs, writer.rs
- `migrations/001_create_audit_log.sql` exists with correct DDL
- No compile-time DATABASE_URL required (runtime queries only)
</verification>

<success_criteria>
The audit module compiles and is importable. AuditEntry captures all AUDIT-01 fields. The writer task pattern satisfies AUDIT-03 (async, non-blocking). The embedded migration satisfies DEPLOY-04. No existing tests break.
</success_criteria>

<output>
After completion, create `.planning/phases/05-audit-logging/05-01-SUMMARY.md`
</output>
