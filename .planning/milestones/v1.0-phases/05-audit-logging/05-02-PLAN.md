---
phase: 05-audit-logging
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - src/gateway.rs
  - src/main.rs
  - tests/gateway_integration_test.rs
autonomous: true
requirements: [AUDIT-01, AUDIT-02]

must_haves:
  truths:
    - "Every tools/call generates a UUID request_id and measures latency"
    - "After each tools/call completes, an AuditEntry is sent to the audit channel via try_send"
    - "If the audit channel is full, a warning is logged and the entry is dropped (never blocks)"
    - "When audit is disabled (no Postgres), dispatch works exactly as before"
    - "main.rs creates PgPool, runs migrations, spawns audit_writer, passes audit_tx to dispatch"
  artifacts:
    - path: "src/gateway.rs"
      provides: "Audit-instrumented dispatch loop with UUID + latency tracking per tools/call"
      contains: "try_send"
    - path: "src/main.rs"
      provides: "PgPool init, migration run, audit channel + writer spawn, audit_tx passed to dispatch"
      contains: "run_migrations"
    - path: "tests/gateway_integration_test.rs"
      provides: "Tests proving dispatch works with and without audit channel"
  key_links:
    - from: "src/gateway.rs"
      to: "src/audit/db.rs"
      via: "AuditEntry struct constructed and sent via mpsc channel"
      pattern: "AuditEntry"
    - from: "src/main.rs"
      to: "src/audit/db.rs"
      via: "create_pool and run_migrations called at startup"
      pattern: "create_pool"
    - from: "src/main.rs"
      to: "src/audit/writer.rs"
      via: "tokio::spawn(audit_writer(pool, rx))"
      pattern: "audit_writer"
    - from: "src/gateway.rs"
      to: "dispatch channel"
      via: "try_send on audit_tx (non-blocking)"
      pattern: "try_send"
---

<objective>
Wire audit logging into the dispatch loop and main.rs startup sequence so every tools/call is recorded.

Purpose: Connects the audit infrastructure (Plan 01) to the live request path, completing all Phase 5 requirements.
Output: Modified gateway.rs with per-call UUID + latency + audit entry emission, modified main.rs with Postgres startup and audit channel plumbing.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-audit-logging/05-RESEARCH.md
@.planning/phases/05-audit-logging/05-01-SUMMARY.md
@src/gateway.rs
@src/main.rs
@src/config/types.rs
@tests/gateway_integration_test.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add audit instrumentation to gateway.rs dispatch loop</name>
  <files>
    src/gateway.rs
  </files>
  <action>
Modify `run_dispatch` signature to accept an optional audit sender:
```rust
pub async fn run_dispatch(
    mut rx: mpsc::Receiver<String>,
    tx: mpsc::Sender<String>,
    catalog: &ToolCatalog,
    backends: &HashMap<String, HttpBackend>,
    id_remapper: &IdRemapper,
    caller: Option<CallerIdentity>,
    rbac_config: &RbacConfig,
    audit_tx: Option<mpsc::Sender<AuditEntry>>,  // NEW -- Optional so tests work without Postgres
) -> anyhow::Result<()>
```

In the `"tools/call"` match arm, wrap the existing logic with audit instrumentation:
1. Generate `let request_id = uuid::Uuid::new_v4();` at the start of the arm
2. Record `let start = std::time::Instant::now();` before calling handle_tools_call
3. After getting the response, compute `let latency_ms = start.elapsed().as_millis() as i64;`
4. Extract tool_name and backend_name (tool_name is already extracted; get backend_name from `catalog.route(&name)`)
5. Determine response_status: if resp.error is Some then "error" else "success"
6. Extract error_message from resp.error if present
7. Extract request_args from the original params
8. Build an AuditEntry with all fields (using caller.subject, caller.role, etc.)
9. If `audit_tx` is Some, call `audit_tx.try_send(entry)` -- if Err (channel full), log warning via tracing::warn. NEVER await or block.
10. Also emit audit entries for RBAC-denied tools/call (response_status = "denied", latency_ms = 0)

Add imports at top: `use crate::audit::db::AuditEntry;` and `use uuid::Uuid;`

The audit entry for a successful/failed call:
- request_id: generated UUID
- timestamp: chrono::Utc::now()
- client_subject: caller.subject.clone()
- client_role: caller.role.clone()
- tool_name: from params
- backend_name: from catalog.route() or "unknown"
- request_args: params.clone() (the full JSON value)
- response_status: "success" | "error" | "denied"
- error_message: from response error or RBAC denial message
- latency_ms: measured duration

The audit entry for RBAC denial:
- Same fields but response_status = "denied", error_message = "Permission denied for tool: {name}", latency_ms = 0, backend_name = catalog.route(&name) or "unknown"
  </action>
  <verify>
`cargo build --release 2>&1` compiles cleanly. Grep gateway.rs for `try_send` to confirm non-blocking send. Grep for `Uuid::new_v4` to confirm request ID generation. Grep for `Instant::now` to confirm latency measurement.
  </verify>
  <done>Every tools/call (including RBAC denials) generates a UUID, measures latency, constructs an AuditEntry, and sends it via try_send on the audit channel. No blocking. Compiles cleanly.</done>
</task>

<task type="auto">
  <name>Task 2: Wire audit startup in main.rs and update integration tests</name>
  <files>
    src/main.rs
    tests/gateway_integration_test.rs
  </files>
  <action>
**main.rs changes:**

After the JWT authentication block and before the stdio transport setup, add the audit initialization:

1. If `config.gateway.audit_enabled` is true:
   a. Resolve Postgres URL via `std::env::var(&config.postgres.url_env)`
   b. If URL is available: create pool via `audit::db::create_pool(&url, config.postgres.max_connections).await?`
   c. Run migrations: `audit::db::run_migrations(&pool).await?`
   d. Create bounded channel: `let (audit_tx, audit_rx) = mpsc::channel::<audit::db::AuditEntry>(1024);`
   e. Spawn writer: `tokio::spawn(audit::writer::audit_writer(pool, audit_rx));`
   f. Log: `tracing::info!("Audit logging enabled (Postgres)")`
   g. Pass `Some(audit_tx)` to run_dispatch
   h. If URL env var is missing/empty: log warning "Postgres URL not set, audit logging disabled" and pass `None`
2. If `config.gateway.audit_enabled` is false:
   a. Log: `tracing::info!("Audit logging disabled")`
   b. Pass `None` to run_dispatch

Add import: `use sentinel_gateway::audit;`

Update the run_dispatch call to include the new audit_tx parameter.

**Integration test changes:**

Update ALL existing calls to `run_dispatch()` to pass `None` as the `audit_tx` parameter (8th argument). This is the minimal change -- existing tests don't need Postgres.

Add 1 new test `test_dispatch_accepts_none_audit_tx` that confirms dispatch works correctly with `audit_tx: None` (tools/call succeeds, no panic). This is basically a smoke test that the Option parameter works.
  </action>
  <verify>
`cargo build --release 2>&1` compiles cleanly. `cargo test 2>&1` passes all tests (existing 85 + new ones). Grep main.rs for `run_migrations` and `audit_writer` to confirm startup wiring. Grep tests for `None` on the audit parameter to confirm all updated.
  </verify>
  <done>main.rs initializes PgPool + migrations + audit writer when audit_enabled and Postgres URL available. All existing integration tests pass with None audit_tx. New smoke test confirms dispatch works without audit. Total test count >= 86.</done>
</task>

</tasks>

<verification>
- `cargo build --release` compiles cleanly
- `cargo test` passes all tests (85 existing + new)
- gateway.rs tools/call path generates UUID, measures latency, sends AuditEntry via try_send
- main.rs creates PgPool, runs migrations, spawns writer when audit enabled
- main.rs gracefully handles missing Postgres (audit disabled, gateway still starts)
- No existing test regressions
</verification>

<success_criteria>
Every tools/call is instrumented with a unique request UUID (AUDIT-02) and all required fields (AUDIT-01). Audit writes go through a bounded channel + background task (AUDIT-03 from Plan 01). Migrations run at startup (DEPLOY-04 from Plan 01). The gateway works identically to before when audit is disabled.
</success_criteria>

<output>
After completion, create `.planning/phases/05-audit-logging/05-02-SUMMARY.md`
</output>
