---
phase: 06-rate-limiting-kill-switch
plan: 02
type: execute
wave: 2
depends_on: [06-01]
files_modified:
  - src/gateway.rs
  - src/main.rs
  - tests/gateway_integration_test.rs
autonomous: true
requirements: [RATE-01, RATE-03, KILL-01, KILL-02]

must_haves:
  truths:
    - "A client exceeding rate limit receives -32004 error with retryAfter in data"
    - "A disabled tool returns -32005 error on tools/call"
    - "A disabled backend causes all its tools to return -32005 error on tools/call"
    - "Disabled tools are hidden from tools/list response"
    - "Disabled backend tools are hidden from tools/list response"
    - "Rate-limited and killed requests emit audit entries"
  artifacts:
    - path: "src/gateway.rs"
      provides: "Dispatch loop with kill switch and rate limit checks before RBAC"
      contains: "KILL_SWITCH_ERROR"
    - path: "src/main.rs"
      provides: "RateLimiter construction and passing to run_dispatch"
      contains: "RateLimiter::new"
    - path: "tests/gateway_integration_test.rs"
      provides: "Integration tests for rate limiting and kill switch"
      min_lines: 50
  key_links:
    - from: "src/gateway.rs"
      to: "src/ratelimit.rs"
      via: "rate_limiter.check(client, tool)"
      pattern: "rate_limiter\\.check"
    - from: "src/gateway.rs"
      to: "src/config/types.rs"
      via: "kill_switch.disabled_tools and disabled_backends"
      pattern: "kill_switch\\.disabled"
    - from: "src/main.rs"
      to: "src/ratelimit.rs"
      via: "RateLimiter::new(&config.rate_limits)"
      pattern: "RateLimiter::new"
---

<objective>
Wire kill switch checks and rate limiting into the dispatch loop, update main.rs to construct and pass the RateLimiter, and add integration tests.

Purpose: Completes Phase 6 by making the gateway actually enforce rate limits and kill switches on every request.
Output: Updated `gateway.rs` dispatch loop, updated `main.rs` startup, comprehensive integration tests.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-rate-limiting-kill-switch/06-RESEARCH.md
@.planning/phases/06-rate-limiting-kill-switch/06-01-SUMMARY.md
@src/gateway.rs
@src/main.rs
@src/config/types.rs
@tests/gateway_integration_test.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add kill switch and rate limit checks to dispatch loop</name>
  <files>src/gateway.rs, src/main.rs</files>
  <action>
**gateway.rs changes:**

1. Add imports for the new types:
```rust
use crate::config::types::KillSwitchConfig;
use crate::protocol::jsonrpc::{RATE_LIMIT_ERROR, KILL_SWITCH_ERROR};
use crate::ratelimit::RateLimiter;
```

2. Update `run_dispatch` signature to accept two new parameters:
```rust
pub async fn run_dispatch(
    mut rx: mpsc::Receiver<String>,
    tx: mpsc::Sender<String>,
    catalog: &ToolCatalog,
    backends: &HashMap<String, HttpBackend>,
    id_remapper: &IdRemapper,
    caller: Option<CallerIdentity>,
    rbac_config: &RbacConfig,
    audit_tx: Option<mpsc::Sender<AuditEntry>>,
    rate_limiter: &RateLimiter,
    kill_switch: &KillSwitchConfig,
) -> anyhow::Result<()> {
```

3. In the `"tools/list"` branch, add kill switch filtering BEFORE the existing RBAC filter. Filter out tools whose name is in `kill_switch.disabled_tools`, AND tools whose backend (via `catalog.route()`) is in `kill_switch.disabled_backends`.

4. In the `"tools/call"` branch, add checks AFTER tool name extraction but BEFORE the existing RBAC check. Order of new checks:

   a. **Tool kill switch** -- if `kill_switch.disabled_tools.contains(&name.to_string())`, return `JsonRpcResponse::error(id, KILL_SWITCH_ERROR, "Tool is disabled: {name}")`. Emit audit entry with `response_status: "killed"`, `latency_ms: 0`. Continue.

   b. **Backend kill switch** -- look up backend via `catalog.route(name)`. If backend is in `kill_switch.disabled_backends`, return `JsonRpcResponse::error(id, KILL_SWITCH_ERROR, "Backend is disabled: {backend}")`. Emit audit entry with `response_status: "killed"`, `latency_ms: 0`. Continue.

   c. **Rate limit** -- call `rate_limiter.check(&caller.subject, name)`. If Err(retry_after), return `JsonRpcResponse::error_with_data(id, RATE_LIMIT_ERROR, "Rate limit exceeded for tool: {name}", json!({"retryAfter": retry_after.ceil() as u64}))`. Emit audit entry with `response_status: "rate_limited"`, `latency_ms: 0`. Continue.

   The audit entry pattern for these rejections is identical to the existing RBAC denial pattern (same struct, same try_send).

**main.rs changes:**

1. Add import: `use sentinel_gateway::ratelimit::RateLimiter;`

2. After the audit_tx initialization block and before the channel creation, construct the rate limiter:
```rust
let rate_limiter = RateLimiter::new(&config.rate_limits);
```

3. Update the `run_dispatch` call to pass the two new arguments:
```rust
sentinel_gateway::gateway::run_dispatch(
    inbound_rx,
    outbound_tx,
    &catalog,
    &backends_map,
    &id_remapper,
    caller,
    &config.rbac,
    audit_tx,
    &rate_limiter,
    &config.kill_switch,
)
.await?;
```
  </action>
  <verify>Run `cargo build --release 2>&1 | tail -5` -- compiles with no errors. Existing tests will fail until Task 2 updates them.</verify>
  <done>Dispatch loop checks kill switch (tool + backend) then rate limit before RBAC. main.rs constructs RateLimiter and passes it along with KillSwitchConfig.</done>
</task>

<task type="auto">
  <name>Task 2: Update existing tests and add integration tests</name>
  <files>tests/gateway_integration_test.rs</files>
  <action>
1. **Update all existing test helpers** to pass the two new parameters to `run_dispatch`:

   - Add imports: `use sentinel_gateway::ratelimit::RateLimiter;` and `use sentinel_gateway::config::types::{RateLimitConfig, KillSwitchConfig};`
   - In `spawn_dispatch()` and `spawn_dispatch_with_caller()`, create default instances:
     ```rust
     let rate_limiter = RateLimiter::new(&RateLimitConfig::default());
     let rate_limiter: &'static _ = Box::leak(Box::new(rate_limiter));
     let kill_switch = KillSwitchConfig::default();
     let kill_switch: &'static _ = Box::leak(Box::new(kill_switch));
     ```
   - Pass `rate_limiter` and `kill_switch` as the last two args to `run_dispatch`
   - Also update `test_tools_call_backend_not_in_map_returns_internal_error` which calls `run_dispatch` directly

2. **Add a new helper** `spawn_dispatch_with_config` that accepts `Option<CallerIdentity>`, `&'static RbacConfig`, `&'static RateLimiter`, `&'static KillSwitchConfig` for the new tests.

3. **Add kill switch integration tests:**

   - `test_kill_switch_tool_disabled_returns_error`: Configure `KillSwitchConfig { disabled_tools: vec!["read_query"], disabled_backends: vec![] }`. Call `tools/call` for `read_query` -- assert error code -32005 and message contains "disabled".

   - `test_kill_switch_tool_hidden_from_list`: Same config. Call `tools/list` -- assert `read_query` is NOT in the returned tools array, but other tools ARE present.

   - `test_kill_switch_backend_disabled_returns_error`: Configure `KillSwitchConfig { disabled_tools: vec![], disabled_backends: vec!["stub-sqlite"] }`. Call `tools/call` for `read_query` (owned by stub-sqlite) -- assert error code -32005 and message contains "disabled".

   - `test_kill_switch_backend_disabled_hides_tools_from_list`: Same config. Call `tools/list` -- assert neither `read_query` nor `write_query` appear (both owned by stub-sqlite), but `list_workflows` and `execute_workflow` do appear.

4. **Add rate limit integration tests:**

   - `test_rate_limit_exceeded_returns_error`: Configure `RateLimitConfig { default_rpm: 2, per_tool: HashMap::new() }`. Do handshake, call `tools/call` for `read_query` 3 times. First 2 should NOT return -32004. Third should return -32004 with `error.data.retryAfter` as a positive integer.

   - `test_rate_limit_per_tool_override`: Configure `RateLimitConfig { default_rpm: 100, per_tool: { "read_query": 1 } }`. Call `tools/call` for `read_query` twice. Second should return -32004. Call for `list_workflows` should still work (uses default 100 RPM).

5. **Verify all existing tests still pass** -- they use default configs (no rate limiting, no kill switch), so behavior is unchanged.
  </action>
  <verify>Run `cargo test 2>&1 | tail -30` -- ALL tests pass (existing + new). Run `cargo build --release 2>&1 | tail -5` -- no warnings.</verify>
  <done>All existing integration tests pass with updated signatures. 6 new integration tests prove kill switch (tool + backend, list + call) and rate limiting (default + per-tool override) work correctly.</done>
</task>

</tasks>

<verification>
1. `cargo build --release` succeeds with no warnings
2. `cargo test` -- all tests pass (existing + new)
3. Kill switch tests prove: disabled tool returns -32005, disabled backend returns -32005, disabled tools hidden from tools/list
4. Rate limit tests prove: exceeded limit returns -32004 with retryAfter, per-tool override works
5. Dispatch order is: kill switch -> rate limit -> RBAC -> backend call
</verification>

<success_criteria>
- Every tools/call passes through kill switch check, then rate limit check, then RBAC, then backend routing
- Disabled tools and backends are invisible in tools/list and return errors on tools/call
- Rate-limited requests get -32004 with retryAfter data
- All rejection types (killed, rate_limited) emit audit entries
- All pre-existing tests continue to pass unchanged in behavior
</success_criteria>

<output>
After completion, create `.planning/phases/06-rate-limiting-kill-switch/06-02-SUMMARY.md`
</output>
