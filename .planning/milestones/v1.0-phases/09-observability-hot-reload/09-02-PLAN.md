---
phase: 09-observability-hot-reload
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/validation/mod.rs
  - src/config/hot.rs
  - src/lib.rs
  - Cargo.toml
autonomous: true
requirements: [OBS-03, OBS-04, CONFIG-03, KILL-03]

must_haves:
  truths:
    - "SchemaCache validates tool arguments against JSON schemas and returns descriptive error messages with field paths"
    - "SchemaCache gracefully handles tools with invalid or missing schemas (skip validation, do not crash)"
    - "HotConfig bundles kill_switch and rate_limiter behind a single Arc<tokio::sync::RwLock<>> for atomic swap"
    - "Config reload function re-reads sentinel.toml and returns new HotConfig or an error (keeping previous config on failure)"
  artifacts:
    - path: "src/validation/mod.rs"
      provides: "SchemaCache struct with from_catalog() and validate() methods"
      exports: ["SchemaCache"]
    - path: "src/config/hot.rs"
      provides: "HotConfig struct and reload_hot_config() function"
      exports: ["HotConfig", "reload_hot_config"]
  key_links:
    - from: "src/validation/mod.rs"
      to: "src/catalog/mod.rs"
      via: "from_catalog takes &ToolCatalog reference"
      pattern: "ToolCatalog"
    - from: "src/config/hot.rs"
      to: "src/config/mod.rs"
      via: "reload_hot_config calls load_config_lenient"
      pattern: "load_config_lenient"
---

<objective>
Create schema validation module and hot-reloadable config struct for zero-downtime kill switch and rate limit changes.

Purpose: Schema validation rejects invalid tool arguments at the gateway before they reach backends (reducing backend load and improving error messages). HotConfig enables SIGHUP-triggered config reload for kill switch and rate limit changes without restarting the gateway.
Output: `src/validation/mod.rs` and `src/config/hot.rs` -- standalone modules ready to be wired into gateway dispatch in Plan 03.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-observability-hot-reload/9-RESEARCH.md
@src/catalog/mod.rs
@src/config/mod.rs
@src/config/types.rs
@src/ratelimit.rs
@src/lib.rs
@Cargo.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create SchemaCache module for JSON Schema validation of tool arguments</name>
  <files>src/validation/mod.rs, src/lib.rs, Cargo.toml</files>
  <action>
Add `jsonschema = "0.42.1"` to Cargo.toml dependencies.

Create `src/validation/mod.rs` with a `SchemaCache` struct:

```rust
pub struct SchemaCache {
    validators: HashMap<String, jsonschema::Validator>,
}
```

Implement:
- `SchemaCache::from_catalog(catalog: &ToolCatalog) -> Self` -- iterates catalog.all_tools(), extracts each tool's `input_schema` (which is `Arc<serde_json::Map<String, Value>>`), converts to `serde_json::Value::Object`, compiles with `jsonschema::validator_for()`. On compilation failure, log a `tracing::warn!` and skip that tool (do NOT crash). Store compiled validators in HashMap keyed by tool name.
- `SchemaCache::validate(tool_name: &str, arguments: &serde_json::Value) -> Result<(), Vec<String>>` -- if no validator exists for the tool, return Ok (no schema = no validation). If validator exists, run `validator.iter_errors(arguments)` and collect error messages as `format!("{} at {}", error, error.instance_path)`. Return Ok if empty, Err(errors) if not.

Note on Tool.input_schema: In rmcp 0.16, `Tool.input_schema` is `Arc<serde_json::Map<String, Value>>` (a JSON object). Convert to Value with `Value::Object((*tool.input_schema).clone())` for jsonschema.

Add `pub mod validation;` to `src/lib.rs`.

Unit tests:
- `test_validate_passes_valid_args` -- create a SchemaCache with a tool schema requiring `{"type": "object", "properties": {"query": {"type": "string"}}, "required": ["query"]}`, validate `{"query": "hello"}` -> Ok
- `test_validate_rejects_invalid_args` -- same schema, validate `{"query": 42}` -> Err with message containing "type"
- `test_validate_rejects_missing_required` -- same schema, validate `{}` -> Err with message containing "required"
- `test_validate_skips_unknown_tool` -- validate a tool not in cache -> Ok
- `test_from_catalog_skips_invalid_schema` -- test that a tool with a broken schema doesn't crash, just gets skipped (create a ToolCatalog with a tool whose schema is intentionally odd but won't crash -- this is a safety test)
  </action>
  <verify>Run `cargo test --lib validation` -- all 5 tests pass. Run `cargo build` -- no warnings.</verify>
  <done>SchemaCache compiles validators from ToolCatalog, validates arguments with descriptive errors including field paths, gracefully skips tools with bad schemas.</done>
</task>

<task type="auto">
  <name>Task 2: Create HotConfig struct and reload function for SIGHUP config reload</name>
  <files>src/config/hot.rs, src/config/mod.rs</files>
  <action>
Create `src/config/hot.rs` with:

```rust
use std::sync::Arc;
use tokio::sync::RwLock;
use crate::config::types::{KillSwitchConfig, RateLimitConfig};
use crate::ratelimit::RateLimiter;

pub struct HotConfig {
    pub kill_switch: KillSwitchConfig,
    pub rate_limiter: RateLimiter,
}

pub type SharedHotConfig = Arc<RwLock<HotConfig>>;
```

Implement:
- `HotConfig::new(kill_switch: KillSwitchConfig, rate_limiter: RateLimiter) -> Self`
- `HotConfig::shared(self) -> SharedHotConfig` -- wraps self in Arc<RwLock<>>
- `reload_hot_config(config_path: &str) -> Result<HotConfig, anyhow::Error>` -- calls `load_config_lenient(config_path)`, extracts kill_switch and rate_limits, creates new RateLimiter, returns HotConfig. On parse/validation failure, returns Err (caller keeps previous config).

IMPORTANT: This does NOT reload backend definitions, auth config, or postgres settings. Only kill_switch and rate_limits. This is by design per research recommendations -- backend/auth changes require restart.

Add `pub mod hot;` to `src/config/mod.rs`.

Add `Clone` derive to `KillSwitchConfig` in `src/config/types.rs` (needed for HotConfig creation from parsed config).

Unit tests:
- `test_hot_config_new` -- creates HotConfig, verifies fields accessible
- `test_reload_hot_config_valid` -- write a temp sentinel.toml with kill_switch and rate_limits sections, call reload_hot_config, verify returned HotConfig has correct values
- `test_reload_hot_config_invalid_file` -- call with non-existent path, verify Err returned
  </action>
  <verify>Run `cargo test --lib config::hot` -- all 3 tests pass. Run `cargo build` -- no warnings.</verify>
  <done>HotConfig struct bundles kill_switch + rate_limiter, SharedHotConfig type alias provides Arc<RwLock<>> wrapper, reload function re-parses config and returns new HotConfig or error.</done>
</task>

</tasks>

<verification>
- `cargo test --lib validation` passes all tests
- `cargo test --lib config::hot` passes all tests
- `cargo build` compiles without warnings
- `grep "pub struct SchemaCache" src/validation/mod.rs` confirms module exists
- `grep "pub struct HotConfig" src/config/hot.rs` confirms module exists
</verification>

<success_criteria>
- SchemaCache validates tool arguments with descriptive error messages including field paths
- SchemaCache handles missing/invalid schemas gracefully (skip, don't crash)
- HotConfig bundles kill_switch + rate_limiter for atomic swap via Arc<RwLock<>>
- reload_hot_config re-reads sentinel.toml and returns new config or error
- Neither module touches gateway.rs or main.rs (wiring deferred to Plan 03)
</success_criteria>

<output>
After completion, create `.planning/phases/09-observability-hot-reload/09-02-SUMMARY.md`
</output>
