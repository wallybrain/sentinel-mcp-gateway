---
phase: 01-foundation-config
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Cargo.toml
  - .gitignore
  - .env.example
  - sentinel.toml
  - src/main.rs
  - src/lib.rs
  - src/cli.rs
  - src/logging.rs
  - src/config/mod.rs
  - src/config/types.rs
  - src/config/secrets.rs
autonomous: true
requirements: [CONFIG-01, CONFIG-02, CONFIG-04, DEPLOY-01]

must_haves:
  truths:
    - "cargo build --release produces a binary with no errors or warnings"
    - "The binary loads sentinel.toml and prints config summary to stderr"
    - "The binary fails fast with a clear error if sentinel.toml is missing"
    - "The binary fails fast with a clear error if sentinel.toml is malformed"
    - "Secrets are read from environment variables, never from the config file"
    - "The config defines backends, RBAC roles, rate limits, and kill switches"
  artifacts:
    - path: "Cargo.toml"
      provides: "Project manifest with Phase 1 dependencies"
      contains: "sentinel-gateway"
    - path: "sentinel.toml"
      provides: "Example config with all sections and placeholder values"
      contains: "[[backends]]"
    - path: "src/main.rs"
      provides: "Entry point with mimalloc, tokio::main, dotenvy, clap, config load"
      min_lines: 20
    - path: "src/config/mod.rs"
      provides: "load_config() and validate() functions"
      exports: ["load_config"]
    - path: "src/config/types.rs"
      provides: "SentinelConfig, BackendConfig, RbacConfig, RateLimitConfig, KillSwitchConfig structs"
      contains: "SentinelConfig"
    - path: "src/config/secrets.rs"
      provides: "Env var resolution for secrets"
      contains: "resolve"
  key_links:
    - from: "src/main.rs"
      to: "src/config/mod.rs"
      via: "load_config() call"
      pattern: "config::load_config"
    - from: "src/config/mod.rs"
      to: "src/config/secrets.rs"
      via: "validate() calls resolve methods"
      pattern: "resolve_jwt_secret|resolve_url"
    - from: "src/main.rs"
      to: "src/cli.rs"
      via: "Cli::parse()"
      pattern: "Cli::parse"
---

<objective>
Scaffold the Sentinel Gateway Rust project with a compiling binary that loads typed TOML configuration, resolves secrets from environment variables, and fails fast on invalid config.

Purpose: Establish the project skeleton and config system that every subsequent phase builds on.
Output: Compiling Rust binary, sentinel.toml example config, typed config structs.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-config/1-RESEARCH.md
@.planning/research/STACK.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Scaffold Cargo project with config system</name>
  <files>
    Cargo.toml
    .gitignore
    .env.example
    sentinel.toml
    src/main.rs
    src/lib.rs
    src/cli.rs
    src/logging.rs
    src/config/mod.rs
    src/config/types.rs
    src/config/secrets.rs
  </files>
  <action>
    Create the Cargo project from scratch (do NOT use `cargo init` -- write files directly).

    **Cargo.toml**: Use the exact dependency list from the Phase 1 research (tokio 1.47 full, serde 1 derive, serde_json 1, toml 0.9, clap 4.5 derive+env, tracing 0.1, tracing-subscriber 0.3 env-filter, thiserror 2, anyhow 1, mimalloc 0.1 no-default-features, dotenvy 0.15). Dev dependency: tokio-test 0.4. Edition 2024, license Proprietary. Release profile: lto fat, codegen-units 1, strip true, panic abort.

    **.gitignore**: target/, .env, *.db, *.sqlite

    **.env.example**: Placeholder values for JWT_SECRET_KEY and DATABASE_URL (e.g., "change-me-in-production").

    **sentinel.toml**: Full example config with all sections from research -- [gateway], [auth], [postgres], [[backends]] (n8n http, sqlite http, context7 stdio, firecrawl stdio, exa stdio, sequential-thinking stdio, playwright stdio), [rbac.roles.admin/developer/viewer], [rate_limits] with default_rpm and per_tool, [kill_switch]. Use placeholder env var names for secrets. Add comments explaining each section.

    **src/config/types.rs**: All config structs from research -- SentinelConfig, GatewayConfig, AuthConfig, PostgresConfig, BackendConfig, BackendType enum (http/stdio), RbacConfig, RoleConfig, RateLimitConfig, KillSwitchConfig. All derive Debug + Deserialize. Use #[serde(default)] with default functions for optional fields. BackendType uses #[serde(rename_all = "lowercase")]. BackendConfig uses #[serde(rename = "type")] for backend_type field.

    **src/config/secrets.rs**: Define ConfigError enum with thiserror (variants: MissingSecret { env_var, context }, MissingConfig { path }). Implement resolve_jwt_secret() on AuthConfig and resolve_url() on PostgresConfig. Each reads std::env::var by the env var NAME stored in config, returns ConfigError::MissingSecret on failure.

    **src/config/mod.rs**: Re-export types and secrets. Implement load_config(path: &str) -> Result<SentinelConfig, anyhow::Error> that reads file, parses TOML, calls validate(). Implement validate() on SentinelConfig that: (1) resolves JWT secret, (2) resolves Postgres URL, (3) checks backend names are unique, (4) checks HTTP backends have url field set, (5) checks stdio backends have command field set. Fail with clear anyhow error messages.

    **src/cli.rs**: Clap derive struct with --config (default "sentinel.toml", env SENTINEL_CONFIG) and --log-level (optional, env LOG_LEVEL).

    **src/logging.rs**: init(level: &str) function that sets up tracing-subscriber with EnvFilter, stderr output, and the provided level.

    **src/lib.rs**: Module declarations for config, cli, logging, and protocol (protocol mod can be empty or have a placeholder mod.rs for now).

    **src/main.rs**: Entry point with #[global_allocator] mimalloc, #[tokio::main], dotenvy::dotenv().ok(), Cli::parse(), load_config(), logging::init(), tracing::info for startup messages. Phase 1 just loads config and exits with success message.

    IMPORTANT: Rust builds require dangerouslyDisableSandbox: true.
  </action>
  <verify>
    Run `cargo build --release` (with dangerouslyDisableSandbox: true) from /home/lwb3/sentinel-gateway/ -- must compile with zero errors and zero warnings.
    Run `cargo build --release 2>&1 | grep -c warning` -- must be 0.
    Set env vars JWT_SECRET_KEY=test and DATABASE_URL=postgres://test and run `./target/release/sentinel-gateway --config sentinel.toml` -- must print startup info and exit cleanly.
    Run without env vars -- must fail with clear error about missing JWT_SECRET_KEY.
    Run with --config nonexistent.toml -- must fail with clear error about missing config file.
  </verify>
  <done>
    cargo build --release succeeds with 0 warnings. Binary loads sentinel.toml, resolves env vars, validates config, and logs startup info. Missing config or env vars produce clear error messages and non-zero exit code.
  </done>
</task>

<task type="auto">
  <name>Task 2: Config integration tests</name>
  <files>
    tests/config_test.rs
  </files>
  <action>
    Create integration tests in tests/config_test.rs that validate the config system end-to-end.

    Tests to write:
    1. **valid_config_loads**: Write a minimal valid sentinel.toml to a temp file, set required env vars, call load_config(), assert it succeeds and fields are correct.
    2. **missing_config_file_errors**: Call load_config("nonexistent.toml"), assert it returns Err with message containing the path.
    3. **malformed_toml_errors**: Write invalid TOML to temp file, call load_config(), assert Err with parse error context.
    4. **missing_jwt_secret_env_errors**: Write valid TOML referencing JWT_SECRET_KEY env var, don't set the env var, call load_config(), assert Err mentioning the env var name.
    5. **duplicate_backend_names_errors**: Write config with two backends named "n8n", call load_config(), assert Err mentioning "Duplicate backend name".
    6. **http_backend_without_url_errors**: Write config with http backend that has no url field, assert validation error.
    7. **stdio_backend_without_command_errors**: Write config with stdio backend that has no command field, assert validation error.
    8. **defaults_applied**: Load minimal config (only required fields), verify defaults are applied (listen = "127.0.0.1:9200", log_level = "info", default_rpm = 1000).

    Use std::io::Write to create temp config files in std::env::temp_dir(). Use std::env::set_var/remove_var for env vars (note: env var tests must be careful about test parallelism -- use unique env var names per test or run with --test-threads=1).

    IMPORTANT: Rust builds require dangerouslyDisableSandbox: true.
  </action>
  <verify>
    Run `cargo test --test config_test` (with dangerouslyDisableSandbox: true) -- all tests pass.
  </verify>
  <done>
    All 8 config integration tests pass. Config loading, validation, secret resolution, and error reporting are all tested.
  </done>
</task>

</tasks>

<verification>
1. `cargo build --release` produces binary with 0 errors, 0 warnings
2. `cargo test` passes all unit and integration tests
3. Binary loads sentinel.toml and prints config summary
4. Binary fails fast with clear errors for: missing config, malformed TOML, missing env vars, duplicate backend names, invalid backend definitions
5. No secrets in committed files (sentinel.toml uses env var names, .env.example has placeholders)
</verification>

<success_criteria>
- cargo build --release succeeds cleanly
- Binary loads typed TOML config with all sections (backends, RBAC, rate limits, kill switches)
- Secrets resolved from environment variables at startup
- Invalid config produces actionable error messages
- 8 integration tests pass covering happy path and error cases
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-config/01-01-SUMMARY.md`
</output>
