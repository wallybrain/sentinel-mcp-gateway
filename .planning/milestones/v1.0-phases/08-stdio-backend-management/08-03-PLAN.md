---
phase: 08-stdio-backend-management
plan: 03
type: execute
wave: 3
depends_on: ["08-01", "08-02"]
files_modified:
  - src/gateway.rs
  - src/main.rs
  - src/backend/mod.rs
  - tests/stdio_integration.rs
autonomous: true
requirements: [ROUTE-02]

must_haves:
  truths:
    - "A tools/call request for a stdio-backed tool routes correctly and returns the response"
    - "tools/list includes tools from both HTTP and stdio backends"
    - "Stdio backends are spawned on gateway startup from config"
    - "On gateway shutdown, all stdio child processes are terminated via process group kill"
    - "The dispatch loop handles both HTTP and stdio backends transparently"
  artifacts:
    - path: "src/gateway.rs"
      provides: "Dispatch that routes to both HttpBackend and StdioBackend"
      contains: "StdioBackend"
    - path: "src/main.rs"
      provides: "Stdio backend spawning and supervisor lifecycle in startup sequence"
      contains: "run_supervisor"
    - path: "tests/stdio_integration.rs"
      provides: "Integration tests proving stdio routing works end-to-end"
      min_lines: 50
  key_links:
    - from: "src/gateway.rs"
      to: "src/backend/stdio.rs"
      via: "StdioBackend::send() called from handle_tools_call"
      pattern: "StdioBackend"
    - from: "src/main.rs"
      to: "src/backend/stdio.rs"
      via: "spawn supervisors for stdio backends from config"
      pattern: "run_supervisor"
    - from: "src/gateway.rs"
      to: "Backend enum"
      via: "unified dispatch over HTTP or stdio"
      pattern: "Backend::Http|Backend::Stdio"
---

<objective>
Wire StdioBackend into the gateway dispatch loop and main.rs startup sequence so stdio-backed tools are routed, discovered, and governed identically to HTTP backends.

Purpose: This completes Phase 8 -- the gateway can now manage stdio MCP servers as first-class backends with the same auth, audit, rate limiting, kill switch, and circuit breaker enforcement as HTTP backends.
Output: Updated `gateway.rs` and `main.rs`, plus integration tests proving end-to-end stdio routing.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-stdio-backend-management/08-RESEARCH.md
@.planning/phases/08-stdio-backend-management/08-01-SUMMARY.md
@.planning/phases/08-stdio-backend-management/08-02-SUMMARY.md
@src/gateway.rs
@src/main.rs
@src/backend/stdio.rs
@src/backend/http.rs
@src/backend/mod.rs
@src/catalog/mod.rs
@src/config/types.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Backend enum and update gateway dispatch to route to both HTTP and stdio</name>
  <files>src/backend/mod.rs, src/gateway.rs</files>
  <action>
**In `src/backend/mod.rs`**, add a `Backend` enum:

```rust
pub enum Backend {
    Http(HttpBackend),
    Stdio(StdioBackend),
}

impl Backend {
    pub async fn send(&self, json_rpc_body: &str) -> Result<String, BackendError> {
        match self {
            Backend::Http(h) => h.send(json_rpc_body).await,
            Backend::Stdio(s) => s.send(json_rpc_body).await,
        }
    }
}
```

Export `Backend` from `src/backend/mod.rs`.

**In `src/gateway.rs`**, change the dispatch to use the unified Backend enum:

1. Change `run_dispatch` parameter from `backends: &HashMap<String, HttpBackend>` to `backends: &HashMap<String, Backend>`
2. Change `handle_tools_call` parameter from `backends: &HashMap<String, HttpBackend>` to `backends: &HashMap<String, Backend>`
3. In `handle_tools_call`, the backend lookup (`backends.get(&backend_name)`) already returns the right thing -- just call `backend.send(&body).await` which dispatches via the enum match
4. Remove the `use crate::backend::HttpBackend;` import, replace with `use crate::backend::Backend;`

This is a minimal change -- the dispatch logic, error handling, circuit breaker recording, ID remapping, and audit logging all remain identical. The Backend enum just delegates `send()`.
  </action>
  <verify>`cargo check` compiles with no errors. All existing tests still pass (`cargo test`).</verify>
  <done>gateway.rs dispatches tool calls to both HTTP and stdio backends transparently via Backend enum. All existing tests pass.</done>
</task>

<task type="auto">
  <name>Task 2: Wire stdio backend spawning and supervisor into main.rs, write integration tests</name>
  <files>src/main.rs, tests/stdio_integration.rs</files>
  <action>
**In `src/main.rs`**, add stdio backend startup after HTTP backend discovery:

1. Change `backends_map` type from `HashMap<String, HttpBackend>` to `HashMap<String, Backend>`
2. Wrap existing HTTP backends: when inserting into backends_map, wrap as `Backend::Http(backend)`
3. Filter stdio backends from config: `config.backends.iter().filter(|b| b.backend_type == BackendType::Stdio)`
4. For each stdio backend config:
   - Create a channel `mpsc::channel::<(String, Vec<Tool>, StdioBackend)>(1)` for tool discovery results
   - Spawn `run_supervisor(config.clone(), cancel.clone(), tools_tx)` as a tokio task
   - Store the supervisor JoinHandle for shutdown
5. Collect tool discovery results: for each stdio backend, await the first message from the tools_rx channel (with a timeout of 30s for initial startup). On success:
   - Register tools in catalog via `catalog.register_backend(&name, tools)`
   - Insert `Backend::Stdio(stdio_backend)` into backends_map
   - Set `discovery_succeeded = true`
   - Initialize health map entry and circuit breaker for this backend
6. On timeout: log error, the supervisor will keep trying in the background

**Shutdown sequence update** in main.rs:
- After `cancel.cancel()`, the supervisors will kill their process groups (via the CancellationToken)
- Wait for supervisor JoinHandles with a timeout (5s) before proceeding to audit drain
- Log any supervisors that didn't shut down in time

**Add imports**: `use sentinel_gateway::backend::{Backend, StdioBackend}` and `use sentinel_gateway::backend::stdio::run_supervisor`

**Integration test** in `tests/stdio_integration.rs`:

Create a test that proves end-to-end stdio routing through the dispatch loop:

1. Create a simple mock stdio MCP server script (inline bash or a small helper): a script that reads JSON-RPC from stdin, responds to `initialize` with capabilities, responds to `tools/list` with a test tool, and responds to `tools/call` by echoing the arguments. Write this as a small shell script to a temp file.
   - Alternative approach if shell script is complex: use `cat` as the child and manually craft the test to work with echo behavior, OR write a tiny Rust helper binary, OR use a Python one-liner that reads stdin JSON and writes responses.
   - Simplest approach: write a small Python script (python3 is available) that acts as a minimal MCP server:
     ```python
     import sys, json
     for line in sys.stdin:
         req = json.loads(line)
         if req.get("method") == "initialize":
             print(json.dumps({"jsonrpc":"2.0","id":req["id"],"result":{"protocolVersion":"2025-03-26","capabilities":{},"serverInfo":{"name":"test","version":"0.1"}}}))
         elif req.get("method") == "tools/list":
             print(json.dumps({"jsonrpc":"2.0","id":req["id"],"result":{"tools":[{"name":"test_tool","description":"A test tool","inputSchema":{"type":"object","properties":{}}}]}}))
         elif req.get("method") == "tools/call":
             print(json.dumps({"jsonrpc":"2.0","id":req["id"],"result":{"content":[{"type":"text","text":"ok"}]}}))
         sys.stdout.flush()
     ```
2. Test `StdioBackend::spawn` with this script, verify `discover_stdio_tools` returns 1 tool
3. Test sending a `tools/call` through the full dispatch loop (spawn StdioBackend, register in catalog, create Backend::Stdio, run dispatch with a tools/call request, verify response)
4. Test that kill_process_group terminates the Python child

Keep the integration test focused: 2-3 test functions, not exhaustive (existing unit tests cover the internals).
  </action>
  <verify>`cargo test` passes all tests (existing + new). `cargo test --test stdio_integration` passes specifically. `cargo check` has no warnings.</verify>
  <done>main.rs spawns stdio backend supervisors on startup, registers discovered tools in catalog, inserts Backend::Stdio into backends_map, and terminates process groups on shutdown. Integration tests prove stdio tools route correctly end-to-end. All tests pass (existing + new).</done>
</task>

</tasks>

<verification>
- `cargo test` passes ALL tests (existing HTTP backend tests still work after Backend enum refactor)
- `cargo test --test stdio_integration` proves stdio routing end-to-end
- `cargo check` compiles with no errors or warnings
- `cargo build --release` produces a single binary
</verification>

<success_criteria>
- tools/call for stdio-backed tools returns correct responses
- tools/list includes tools from both HTTP and stdio backends
- Stdio backends spawned from config on startup with supervisor tasks
- Shutdown terminates all stdio process groups
- All existing tests pass (no regressions from Backend enum refactor)
- At least 2 integration tests prove end-to-end stdio routing
</success_criteria>

<output>
After completion, create `.planning/phases/08-stdio-backend-management/08-03-SUMMARY.md`
</output>
