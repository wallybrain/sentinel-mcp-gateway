---
phase: 08-stdio-backend-management
plan: 02
type: execute
wave: 2
depends_on: ["08-01"]
files_modified:
  - src/backend/stdio.rs
autonomous: true
requirements: [STDIO-02, STDIO-03]

must_haves:
  truths:
    - "A crashed stdio backend is detected when its stdout reader hits EOF"
    - "A crashed stdio backend is restarted with exponential backoff (base 1s, max 60s, jitter)"
    - "Restart respects max_restarts limit from config"
    - "Supervisor stops cleanly when CancellationToken is cancelled (no new child spawned during shutdown)"
    - "MCP handshake (initialize + tools/list) runs after each spawn to discover tools"
  artifacts:
    - path: "src/backend/stdio.rs"
      provides: "supervisor task with crash detection, backoff restart, MCP handshake"
      contains: "supervisor"
  key_links:
    - from: "src/backend/stdio.rs supervisor"
      to: "StdioBackend::spawn"
      via: "respawn on crash"
      pattern: "spawn.*backoff|backoff.*spawn"
    - from: "src/backend/stdio.rs supervisor"
      to: "CancellationToken"
      via: "graceful shutdown stops supervisor loop"
      pattern: "cancel.*cancelled|is_cancelled"
    - from: "src/backend/stdio.rs supervisor"
      to: "discover_stdio_tools"
      via: "MCP handshake after spawn"
      pattern: "discover_stdio_tools|tools/list"
---

<objective>
Add supervisor task for stdio backends that detects crashes, restarts with exponential backoff, and performs MCP tool discovery after each spawn.

Purpose: Stdio backends (node processes) can crash. The gateway must detect this and restart automatically, with backoff to avoid crash loops. After each restart, tools must be re-discovered via MCP handshake.
Output: Updated `src/backend/stdio.rs` with `run_supervisor()` and `discover_stdio_tools()` functions.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-stdio-backend-management/08-RESEARCH.md
@.planning/phases/08-stdio-backend-management/08-01-SUMMARY.md
@src/backend/stdio.rs
@src/backend/http.rs
@src/config/types.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement discover_stdio_tools for MCP handshake over stdio</name>
  <files>src/backend/stdio.rs</files>
  <action>
Add `discover_stdio_tools()` function to `src/backend/stdio.rs`:

```rust
pub async fn discover_stdio_tools(backend: &StdioBackend) -> anyhow::Result<Vec<rmcp::model::Tool>>
```

This parallels `discover_tools()` in `src/backend/http.rs` but works over stdio:

1. Send MCP `initialize` request (JSON-RPC id=1) with protocolVersion "2025-03-26", clientInfo name "sentinel-gateway" version "0.1.0" -- via `backend.send()`
2. Send `notifications/initialized` notification (no id) -- write directly to stdin_tx (notifications have no response). Since `send()` requires an id for correlation, write the notification string directly via `stdin_tx.send()`. Add a `pub fn stdin_sender(&self) -> &mpsc::Sender<String>` accessor to StdioBackend for this purpose.
3. Wait a brief moment (100ms) for the server to process the notification
4. Send `tools/list` request (JSON-RPC id=2) via `backend.send()`
5. Parse the response: extract `result.tools` array, deserialize as `Vec<rmcp::model::Tool>`
6. Return the tools

Handle errors: if any step fails, return `anyhow::Error` with context about which step failed. The caller (supervisor) will log and retry on next restart.
  </action>
  <verify>`cargo check` compiles. The function exists and is callable.</verify>
  <done>discover_stdio_tools performs MCP initialize + notifications/initialized + tools/list over a StdioBackend and returns tool definitions.</done>
</task>

<task type="auto">
  <name>Task 2: Implement supervisor task with crash detection and exponential backoff restart</name>
  <files>src/backend/stdio.rs</files>
  <action>
Add `run_supervisor()` async function to `src/backend/stdio.rs`:

```rust
pub async fn run_supervisor(
    config: BackendConfig,
    cancel: CancellationToken,
    on_tools_discovered: mpsc::Sender<(String, Vec<rmcp::model::Tool>, StdioBackend)>,
)
```

Parameters:
- `config` -- the BackendConfig for this stdio backend
- `cancel` -- CancellationToken for graceful shutdown
- `on_tools_discovered` -- channel to send discovered tools back to main (backend name, tools, StdioBackend reference) so the catalog and backend map can be updated

Behavior:
1. Enter supervisor loop
2. Check `cancel.is_cancelled()` before each spawn attempt -- break if true
3. Call `StdioBackend::spawn(&config)` to create child process
4. After spawn, perform MCP handshake via `discover_stdio_tools(&backend)`:
   - On success: send (name, tools, backend) via `on_tools_discovered` channel
   - On failure: log error, kill the child, increment restart count, apply backoff, continue loop
5. Monitor for child exit: the stdout_reader task handle will complete when the child exits (EOF on stdout). Use `tokio::select!` to wait on either:
   - stdout_reader handle completing (child exited/crashed)
   - `cancel.cancelled()` (shutdown signal)
6. On child exit (crash):
   - Log warning with exit status if available
   - Call `drain_pending()` to fail all in-flight requests
   - Call `kill_process_group(pid)` to clean up any orphans
   - Increment `restart_count`, check against `config.max_restarts`
   - If max reached: log error, break
   - Apply exponential backoff: `base_secs * 2^(restart_count - 1)` capped at 60s, with random jitter (0-50% of delay). Use `tokio::select!` on backoff sleep vs `cancel.cancelled()` so shutdown isn't blocked by backoff
   - Continue loop (respawn)
7. On cancel:
   - Log info "shutting down stdio backend"
   - Call `kill_process_group(pid)`
   - Wait for child (via stdout_reader completing or short timeout)
   - Break

Backoff constants: base = 1 second, max = 60 seconds. Jitter via `rand::random::<f64>() * 0.5`.

Reset restart_count to 0 after a successful period of operation (e.g., if the process runs for >60s before crashing, reset the counter -- this prevents permanent death from transient issues).

Export `run_supervisor` from `src/backend/mod.rs`.

Write unit tests:
1. Test supervisor detects child exit: spawn a child that exits immediately (e.g., `echo hello`), verify supervisor restarts it. Use a short cancel after 2 restarts to stop the loop.
2. Test supervisor respects cancellation during backoff: spawn a child that exits, cancel during the backoff sleep, verify supervisor exits promptly (within 1s).
3. Test supervisor stops after max_restarts: set max_restarts=2, spawn a child that exits immediately, verify supervisor stops after 2 restarts.
  </action>
  <verify>`cargo test --lib backend::stdio` passes all tests including new supervisor tests. `cargo check` has no warnings.</verify>
  <done>run_supervisor detects child crashes, restarts with exponential backoff respecting max_restarts, performs MCP handshake after each spawn, and shuts down cleanly on cancellation. At least 3 new tests pass.</done>
</task>

</tasks>

<verification>
- `cargo test --lib backend::stdio` passes all tests
- Supervisor properly integrates with StdioBackend::spawn() from Plan 01
- Cancellation stops the supervisor within 1 second regardless of backoff state
</verification>

<success_criteria>
- run_supervisor detects child exit via stdout EOF
- Exponential backoff (1s, 2s, 4s, ..., 60s cap) with jitter applied between restarts
- max_restarts limit honored
- CancellationToken checked before each spawn and during backoff sleep
- MCP handshake runs after each successful spawn
- Tools communicated back to main via channel
</success_criteria>

<output>
After completion, create `.planning/phases/08-stdio-backend-management/08-02-SUMMARY.md`
</output>
