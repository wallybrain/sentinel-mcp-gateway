---
phase: 04-authentication-authorization
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Cargo.toml
  - src/lib.rs
  - src/auth/mod.rs
  - src/auth/jwt.rs
  - src/auth/rbac.rs
  - tests/auth_test.rs
autonomous: true
requirements: [AUTH-01, AUTH-02, AUTH-03, AUTHZ-01]

must_haves:
  truths:
    - "A valid HS256 JWT with correct exp/iss/aud/sub is accepted and returns Claims"
    - "An expired, malformed, or wrong-signature JWT is rejected with a typed AuthError"
    - "A JWT missing the role claim is rejected"
    - "is_tool_allowed returns true for admin with wildcard permissions"
    - "is_tool_allowed returns false for unknown roles"
    - "denied_tools overrides wildcard permissions"
    - "tools.read permission allows list but not execute, tools.execute allows both"
  artifacts:
    - path: "src/auth/mod.rs"
      provides: "Module declarations for jwt and rbac"
    - path: "src/auth/jwt.rs"
      provides: "JwtValidator, Claims, AuthError, CallerIdentity"
      exports: ["JwtValidator", "Claims", "AuthError", "CallerIdentity"]
    - path: "src/auth/rbac.rs"
      provides: "Single RBAC check function used by both tools/list and tools/call"
      exports: ["is_tool_allowed", "Permission"]
    - path: "tests/auth_test.rs"
      provides: "Unit tests for JWT validation and RBAC logic"
      min_lines: 80
  key_links:
    - from: "src/auth/jwt.rs"
      to: "jsonwebtoken crate"
      via: "decode() with Validation struct"
      pattern: "jsonwebtoken::decode"
    - from: "src/auth/rbac.rs"
      to: "src/config/types.rs"
      via: "RbacConfig and RoleConfig types"
      pattern: "RbacConfig"
---

<objective>
Create the JWT validation and RBAC authorization modules as standalone, testable units.

Purpose: Build the auth foundation that Phase 4 Plan 2 will wire into the dispatch loop. Keeping these modules independent allows thorough unit testing of crypto validation and permission logic before integration.
Output: `src/auth/jwt.rs` with JwtValidator + Claims, `src/auth/rbac.rs` with is_tool_allowed(), comprehensive unit tests.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-authentication-authorization/4-RESEARCH.md
@src/config/types.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create auth module with JwtValidator and RBAC</name>
  <files>Cargo.toml, src/lib.rs, src/auth/mod.rs, src/auth/jwt.rs, src/auth/rbac.rs</files>
  <action>
1. Add `jsonwebtoken` dependency to Cargo.toml:
   ```toml
   jsonwebtoken = { version = "10", default-features = false, features = ["rust_crypto"] }
   ```

2. Add `pub mod auth;` to `src/lib.rs`.

3. Create `src/auth/mod.rs`:
   ```rust
   pub mod jwt;
   pub mod rbac;
   ```

4. Create `src/auth/jwt.rs` with:
   - `AuthError` enum (thiserror) with variants: `InvalidToken(String)`, `ExpiredToken`, `InvalidClaims(String)`, `MissingToken`. Each variant maps to JSON-RPC error code -32001.
   - `Claims` struct (Serialize, Deserialize): `sub: String`, `role: String`, `iss: String`, `aud: String`, `exp: usize`, `iat: Option<usize>`, `jti: Option<String>`.
   - `CallerIdentity` struct: `subject: String`, `role: String`, `token_id: Option<String>`. Implement `From<Claims>` for `CallerIdentity`.
   - `JwtValidator` struct holding `DecodingKey` and `Validation`. Constructor `new(secret: &[u8], issuer: &str, audience: &str)` that:
     - Creates `DecodingKey::from_secret(secret)`
     - Creates `Validation::new(Algorithm::HS256)`
     - Sets issuer, audience, required spec claims (exp, iss, aud, sub)
     - Enables exp validation (default 60s leeway is fine)
   - `validate(&self, token: &str) -> Result<CallerIdentity, AuthError>` that:
     - Calls `decode::<Claims>()` with the stored key and validation
     - Checks `claims.role` is non-empty (reject with `InvalidClaims("missing role")` if empty)
     - Returns `CallerIdentity::from(claims)` on success
     - Maps `jsonwebtoken::errors::ErrorKind` to `AuthError` variants (ExpiredSignature -> ExpiredToken, InvalidIssuer/InvalidAudience/InvalidSignature/InvalidToken -> InvalidToken with message, MissingRequiredClaim -> InvalidClaims)
   - `create_token(claims: &Claims, secret: &[u8]) -> Result<String, AuthError>` helper for tests and CLI token generation. Uses `encode()` with `Header::default()` (HS256).
   - Helper `now_secs() -> usize` using `std::time::SystemTime` (no chrono dependency).

5. Create `src/auth/rbac.rs` with:
   - `Permission` enum: `Read` (tools/list visibility), `Execute` (tools/call access). With a method `required_permission_str() -> &str` returning `"tools.read"` or `"tools.execute"`.
   - `is_tool_allowed(role: &str, tool_name: &str, permission: Permission, rbac: &RbacConfig) -> bool` that:
     - Looks up `role` in `rbac.roles`. Unknown role = return false.
     - Checks `denied_tools` first. If tool_name is in denied_tools, return false (deny overrides wildcard).
     - Checks if `"*"` is in permissions. If so, return true.
     - Checks if the required permission string (e.g., `"tools.execute"`) is in permissions. `"tools.execute"` implies `"tools.read"`.
     - Otherwise return false.
   - This is the SINGLE function used by both `tools/list` and `tools/call` in Plan 02 (different `Permission` variant).
  </action>
  <verify>Run `cargo build --release 2>&1 | tail -5` -- must compile with no errors. Run `cargo check 2>&1 | tail -3` for warnings.</verify>
  <done>New `src/auth/` module compiles, exports JwtValidator, Claims, CallerIdentity, AuthError, is_tool_allowed, Permission.</done>
</task>

<task type="auto">
  <name>Task 2: Unit tests for JWT validation and RBAC</name>
  <files>tests/auth_test.rs</files>
  <action>
Create `tests/auth_test.rs` with comprehensive tests:

**JWT tests:**
- `test_valid_token_accepted`: Create token with valid claims, validate it, assert CallerIdentity has correct subject/role/token_id.
- `test_expired_token_rejected`: Create token with `exp` in the past (more than 60s ago to exceed leeway), validate, assert `AuthError::ExpiredToken`.
- `test_wrong_signature_rejected`: Create token with secret "A", validate with secret "B", assert `AuthError::InvalidToken`.
- `test_wrong_issuer_rejected`: Create token with issuer "wrong", validate with expected issuer "sentinel-gateway", assert `AuthError::InvalidToken`.
- `test_wrong_audience_rejected`: Same pattern for audience.
- `test_missing_role_rejected`: Create token where role is empty string `""`, validate, assert `AuthError::InvalidClaims` mentioning "role".
- `test_malformed_token_rejected`: Call validate with `"not.a.jwt"`, assert error.
- `test_create_and_validate_roundtrip`: Create token, validate it, verify all fields match.

**RBAC tests:**
- `test_admin_wildcard_allows_all`: Role with `permissions: ["*"]`, tool "anything" -> true for both Read and Execute.
- `test_unknown_role_denied`: Role not in config -> false.
- `test_denied_tools_override_wildcard`: Role with `permissions: ["*"]` and `denied_tools: ["secret_tool"]` -> `is_tool_allowed("admin", "secret_tool", Execute, ...)` returns false.
- `test_read_permission_allows_list`: Role with `permissions: ["tools.read"]` -> `is_tool_allowed(role, tool, Read, ...)` true, `is_tool_allowed(role, tool, Execute, ...)` false.
- `test_execute_permission_implies_read`: Role with `permissions: ["tools.execute"]` -> both Read and Execute return true.
- `test_empty_permissions_denied`: Role with empty permissions -> false for both.
- `test_denied_tools_with_execute_permission`: Role has `["tools.execute"]` but tool in denied_tools -> false.

Use a helper function `make_rbac(roles: Vec<(&str, Vec<&str>, Vec<&str>)>) -> RbacConfig` that builds config from (role_name, permissions, denied_tools) tuples.

Use a test constant `TEST_SECRET: &[u8] = b"test-secret-key-for-unit-tests-only";`.
  </action>
  <verify>Run `cargo test auth 2>&1 | tail -20` -- all auth tests pass. Run `cargo test 2>&1 | grep "test result"` -- all existing tests still pass (no regressions).</verify>
  <done>15+ tests covering JWT validation edge cases and RBAC permission logic. All pass alongside existing 60 tests.</done>
</task>

</tasks>

<verification>
- `cargo build --release` compiles cleanly
- `cargo test` runs all tests (existing + new auth tests) with 0 failures
- `src/auth/jwt.rs` exports JwtValidator, Claims, CallerIdentity, AuthError
- `src/auth/rbac.rs` exports is_tool_allowed (single function for both list and call)
</verification>

<success_criteria>
- JwtValidator correctly validates HS256 tokens with exp/iss/aud/sub claim checking
- Invalid tokens produce typed AuthError variants (not panics)
- is_tool_allowed implements deny-first, wildcard, and permission-level logic
- All 15+ new tests pass alongside existing 60 tests
</success_criteria>

<output>
After completion, create `.planning/phases/04-authentication-authorization/04-01-SUMMARY.md`
</output>
