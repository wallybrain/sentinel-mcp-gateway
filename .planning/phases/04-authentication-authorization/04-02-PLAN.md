---
phase: 04-authentication-authorization
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - src/gateway.rs
  - src/main.rs
  - src/catalog/mod.rs
  - tests/gateway_integration_test.rs
autonomous: true
requirements: [AUTHZ-02, AUTHZ-03]

must_haves:
  truths:
    - "tools/list returns only tools the caller's role is permitted to see"
    - "tools/call for an unauthorized tool is rejected with JSON-RPC error -32003"
    - "The same is_tool_allowed function is used for both tools/list and tools/call"
    - "ping and initialize are exempt from auth (transport-level concerns)"
    - "All existing tests still pass after updating for auth"
    - "A request with no token is rejected with JSON-RPC error -32001"
  artifacts:
    - path: "src/gateway.rs"
      provides: "Auth-gated dispatch loop"
      contains: "is_tool_allowed"
    - path: "src/main.rs"
      provides: "JwtValidator construction from config"
      contains: "JwtValidator"
    - path: "tests/gateway_integration_test.rs"
      provides: "Updated integration tests with JWT auth"
      min_lines: 150
  key_links:
    - from: "src/gateway.rs"
      to: "src/auth/rbac.rs"
      via: "is_tool_allowed() called in tools/list and tools/call handlers"
      pattern: "is_tool_allowed"
    - from: "src/gateway.rs"
      to: "src/auth/jwt.rs"
      via: "JwtValidator.validate() on session setup"
      pattern: "validator\\.validate"
    - from: "src/main.rs"
      to: "src/auth/jwt.rs"
      via: "Construct JwtValidator from config at startup"
      pattern: "JwtValidator::new"
---

<objective>
Wire JWT authentication and RBAC authorization into the gateway dispatch loop, making auth mandatory for all tool operations.

Purpose: This is the integration plan -- takes the standalone auth modules from Plan 01 and threads them through the actual request processing pipeline. After this plan, every tool request is authenticated and authorized.
Output: Modified `gateway.rs` with auth enforcement, updated integration tests, `main.rs` constructing JwtValidator.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-authentication-authorization/4-RESEARCH.md
@.planning/phases/04-authentication-authorization/04-01-SUMMARY.md
@src/gateway.rs
@src/main.rs
@src/catalog/mod.rs
@src/config/types.rs
@tests/gateway_integration_test.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire auth into dispatch loop and main.rs</name>
  <files>src/gateway.rs, src/main.rs</files>
  <action>
1. Modify `run_dispatch()` signature in `src/gateway.rs` to accept auth context:
   ```rust
   pub async fn run_dispatch(
       mut rx: mpsc::Receiver<String>,
       tx: mpsc::Sender<String>,
       catalog: &ToolCatalog,
       backends: &HashMap<String, HttpBackend>,
       id_remapper: &IdRemapper,
       jwt_validator: Option<&JwtValidator>,
       rbac_config: &RbacConfig,
   ) -> anyhow::Result<()>
   ```
   Use `Option<&JwtValidator>` so tests can pass `None` for unauthenticated testing (but production always passes `Some`).

2. Add token validation on session setup. Per research recommendation, validate once at session start. The approach:
   - Add a `caller: Option<CallerIdentity>` that starts as `None`.
   - When `jwt_validator` is `Some`, the gateway needs a token. For stdio transport, read from env var `SENTINEL_TOKEN`.
   - Validate the token BEFORE processing the first request. If validation fails, send a JSON-RPC error and close.
   - Specifically: at the top of `run_dispatch`, if `jwt_validator` is `Some`, read `std::env::var("SENTINEL_TOKEN")`, validate it, store `CallerIdentity`. If missing or invalid, send error response (to the first request that arrives) and return.
   - Actually, simpler: validate the token eagerly before entering the loop. If invalid, the function returns an error. The caller (main.rs) logs the error and exits. This is cleaner -- a bad token means the session is invalid, period.

   Revised approach (simpler, cleaner):
   - Before the `while let` loop, if `jwt_validator` is `Some`:
     - Read `SENTINEL_TOKEN` env var. If missing, return `Err(anyhow!("SENTINEL_TOKEN env var required"))`.
     - Call `validator.validate(&token)`. If error, return `Err(anyhow!("Authentication failed: {err}"))`.
     - Store `CallerIdentity` in a local variable.
   - If `jwt_validator` is `None`, create a default admin CallerIdentity (for test/dev mode).

3. Modify `tools/list` handler to filter by role:
   ```rust
   "tools/list" => {
       if !is_notification {
           let id = request.id.clone().unwrap_or(JsonRpcId::Null);
           let tools: Vec<Tool> = catalog.all_tools()
               .into_iter()
               .filter(|tool| is_tool_allowed(&caller.role, &tool.name, Permission::Read, rbac_config))
               .collect();
           let result = ListToolsResult::with_all_items(tools);
           // ... same response construction
       }
   }
   ```

4. Modify `tools/call` handler to check authorization BEFORE routing:
   ```rust
   "tools/call" => {
       if !is_notification {
           let id = request.id.clone().unwrap_or(JsonRpcId::Null);
           // Extract tool name first for RBAC check
           let tool_name = request.params.as_ref()
               .and_then(|p| p.get("name"))
               .and_then(|n| n.as_str());
           if let Some(name) = tool_name {
               if !is_tool_allowed(&caller.role, name, Permission::Execute, rbac_config) {
                   let resp = JsonRpcResponse::error(id, AUTHZ_ERROR, format!("Permission denied for tool: {name}"));
                   send_response(&tx, &resp).await;
                   continue;
               }
           }
           // Then proceed to existing handle_tools_call
           let resp = handle_tools_call(id, request.params, catalog, backends, id_remapper).await;
           send_response(&tx, &resp).await;
       }
   }
   ```
   Add constant `const AUTHZ_ERROR: i32 = -32003;` at top of file.

5. `ping` and `initialize` remain exempt from RBAC (they're protocol-level, not tool-level). Auth happens before the loop, so the session is authenticated, but these methods don't need tool-level authorization.

6. Update `src/main.rs`:
   - After config loading, construct `JwtValidator`:
     ```rust
     let jwt_validator = {
         let secret = std::env::var(&config.auth.jwt_secret_env)
             .unwrap_or_else(|_| {
                 tracing::warn!("JWT secret env var '{}' not set, auth disabled", config.auth.jwt_secret_env);
                 String::new()
             });
         if secret.is_empty() {
             None
         } else {
             Some(sentinel_gateway::auth::jwt::JwtValidator::new(
                 secret.as_bytes(),
                 &config.auth.jwt_issuer,
                 &config.auth.jwt_audience,
             ))
         }
     };
     ```
   - Pass `jwt_validator.as_ref()` and `&config.rbac` to `run_dispatch()`.
  </action>
  <verify>Run `cargo build --release 2>&1 | tail -5` -- must compile with no errors.</verify>
  <done>Dispatch loop validates JWT at session start, filters tools/list by role, blocks unauthorized tools/call with -32003 error.</done>
</task>

<task type="auto">
  <name>Task 2: Update existing tests and add auth integration tests</name>
  <files>tests/gateway_integration_test.rs</files>
  <action>
1. Update `spawn_dispatch()` helper to accept optional auth:
   - Create `spawn_dispatch_with_auth(jwt_validator: Option<&'static JwtValidator>, rbac: &'static RbacConfig)` that passes auth to `run_dispatch`.
   - Update existing `spawn_dispatch()` to call `spawn_dispatch_with_auth(None, &default_rbac)` where `default_rbac` has an admin role with `["*"]` permissions. This ensures all existing tests pass without modification (they get admin access by default when no validator is provided).

2. Create a test helper module at the top of the file:
   ```rust
   const TEST_SECRET: &[u8] = b"test-secret-for-integration-tests";

   fn make_test_validator() -> JwtValidator {
       JwtValidator::new(TEST_SECRET, "sentinel-gateway", "sentinel-api")
   }

   fn make_test_token(role: &str) -> String {
       // Use create_token from auth::jwt with proper claims
   }

   fn make_test_rbac() -> RbacConfig {
       // admin: ["*"], developer: ["tools.read", "tools.execute"], viewer: ["tools.read"]
       // developer denied_tools: ["write_query"]
   }
   ```

3. Add new integration tests:
   - `test_auth_valid_token_tools_list_filtered`: Create validator + RBAC with "viewer" role (tools.read only). Set SENTINEL_TOKEN env var. Call tools/list. Assert response contains tools. Then call tools/call and assert -32003 error.
     Note: Setting env vars in tests is tricky with parallelism. Instead, refactor so the token is passed directly rather than read from env. Add an alternative: `run_dispatch_with_token(token: Option<&str>, ...)` that takes the token directly instead of reading SENTINEL_TOKEN. This is cleaner for testing.

   Actually, better approach: Make `run_dispatch` accept `caller: Option<CallerIdentity>` directly instead of `jwt_validator`. Move the JWT validation to main.rs (validate once, pass identity). This makes gateway.rs purely about dispatch + RBAC, and is much easier to test.

   REVISED gateway.rs approach:
   - `run_dispatch()` takes `caller: Option<CallerIdentity>` and `rbac_config: &RbacConfig` (not JwtValidator).
   - If `caller` is `None`, use a default admin identity (dev/test mode).
   - If `caller` is `Some`, use that identity for RBAC checks.
   - JWT validation happens in `main.rs` before calling `run_dispatch`.

   This is better because:
   - gateway.rs doesn't need to know about env vars or JWT parsing
   - Tests can pass any CallerIdentity directly
   - Separation of concerns: main.rs handles auth, gateway.rs handles dispatch+authz

4. With the revised approach, update spawn_dispatch helpers:
   ```rust
   async fn spawn_dispatch() -> (Sender, Receiver) {
       // No auth, default admin -- existing tests work unchanged
       spawn_dispatch_with_caller(None, &default_admin_rbac()).await
   }

   async fn spawn_dispatch_with_caller(
       caller: Option<CallerIdentity>,
       rbac: &'static RbacConfig,
   ) -> (Sender, Receiver) {
       // ... same as before but passes caller and rbac to run_dispatch
   }
   ```

5. New integration tests to add:
   - `test_viewer_sees_all_tools_in_list`: Viewer with tools.read can see all tools in tools/list (no denied_tools).
   - `test_viewer_cannot_call_tools`: Viewer with tools.read only, tools/call returns -32003.
   - `test_developer_denied_tool_hidden_in_list`: Developer with denied_tools=["write_query"], tools/list does NOT contain "write_query".
   - `test_developer_denied_tool_blocked_in_call`: Developer calls "write_query", gets -32003.
   - `test_developer_can_call_allowed_tool`: Developer calls "read_query" (allowed), gets normal response (will be backend error since no real backend, but NOT -32003).
   - `test_unknown_role_sees_no_tools`: Caller with role "intern" (not in config), tools/list returns empty tools array.
   - `test_unknown_role_cannot_call`: Caller with role "intern", tools/call returns -32003.
   - `test_admin_wildcard_sees_all_tools`: Admin with ["*"], tools/list returns all 4 stub tools.
   - `test_admin_denied_tool_override`: Admin with ["*"] but denied_tools=["execute_workflow"], tool not in list, call returns -32003.
  </action>
  <verify>Run `cargo test 2>&1 | grep "test result"` -- all tests pass (old + new). Run `cargo test auth 2>&1 | tail -20` and `cargo test gateway 2>&1 | tail -30` separately to confirm both suites pass.</verify>
  <done>All existing tests pass unchanged (backward compatible). 9+ new integration tests verify RBAC filtering on tools/list and tools/call enforcement. Same is_tool_allowed function used in both paths (visible in gateway.rs code).</done>
</task>

</tasks>

<verification>
- `cargo build --release` compiles cleanly
- `cargo test` runs all tests with 0 failures
- `tools/list` response is filtered by caller's role
- `tools/call` for unauthorized tool returns error code -32003
- `is_tool_allowed` from `src/auth/rbac.rs` is called in both `tools/list` and `tools/call` code paths in `gateway.rs`
- `ping` and `initialize` still work without tool-level auth
</verification>

<success_criteria>
- Viewer role can list tools but not call them
- Developer role sees tools minus denied_tools, can call allowed tools
- Admin with wildcard sees all tools (minus denied)
- Unknown role sees empty catalog, cannot call any tool
- All pre-existing 60+ tests still pass
- 9+ new auth integration tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/04-authentication-authorization/04-02-SUMMARY.md`
</output>
