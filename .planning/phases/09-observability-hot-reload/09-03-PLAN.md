---
phase: 09-observability-hot-reload
plan: 03
type: execute
wave: 2
depends_on: [09-01, 09-02]
files_modified:
  - src/gateway.rs
  - src/main.rs
autonomous: true
requirements: [OBS-01, OBS-02, OBS-03, OBS-04, CONFIG-03, KILL-03]

must_haves:
  truths:
    - "Every tools/call records metrics (request count, latency, error type) via the Metrics struct"
    - "Tool arguments are validated against cached JSON schemas after RBAC but before circuit breaker"
    - "Invalid arguments return JSON-RPC -32602 error with descriptive message and never reach the backend"
    - "SIGHUP triggers config reload -- kill switch and rate limit changes take effect on next request"
    - "Failed config reload logs error and keeps previous config (no crash, no partial state)"
    - "Rate limit hits and kill switch rejections are recorded in metrics"
  artifacts:
    - path: "src/gateway.rs"
      provides: "Dispatch loop with metrics recording, schema validation, and SharedHotConfig reads"
      contains: "schema_cache.validate"
    - path: "src/main.rs"
      provides: "SIGHUP handler, Metrics wired into health server, SharedHotConfig wired into dispatch"
      contains: "SignalKind::hangup"
  key_links:
    - from: "src/gateway.rs"
      to: "src/metrics/mod.rs"
      via: "Arc<Metrics> parameter, record_request/record_rate_limit_hit calls"
      pattern: "metrics\\.record_"
    - from: "src/gateway.rs"
      to: "src/validation/mod.rs"
      via: "SchemaCache parameter, validate() call in tools/call pipeline"
      pattern: "schema_cache\\.validate"
    - from: "src/gateway.rs"
      to: "src/config/hot.rs"
      via: "SharedHotConfig parameter, .read().await for kill_switch and rate_limiter access"
      pattern: "hot_config\\.read"
    - from: "src/main.rs"
      to: "src/config/hot.rs"
      via: "SIGHUP handler calls reload_hot_config, swaps via .write().await"
      pattern: "reload_hot_config"
    - from: "src/main.rs"
      to: "src/metrics/mod.rs"
      via: "Arc<Metrics> created and passed to health server and dispatch"
      pattern: "Metrics::new"
---

<objective>
Wire metrics, schema validation, and hot config reload into the gateway dispatch loop and main.rs startup.

Purpose: This is the integration plan that connects all Phase 9 modules (metrics, validation, hot config) into the existing gateway. After this plan, all 6 Phase 9 requirements are fully functional end-to-end.
Output: Updated `src/gateway.rs` with metrics recording + schema validation + hot config reads, and updated `src/main.rs` with SIGHUP handler + metrics wiring.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-observability-hot-reload/9-RESEARCH.md
@.planning/phases/09-observability-hot-reload/09-01-SUMMARY.md
@.planning/phases/09-observability-hot-reload/09-02-SUMMARY.md
@src/gateway.rs
@src/main.rs
@src/health/server.rs
@src/config/types.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Refactor gateway dispatch to use SharedHotConfig, Metrics, and SchemaCache</name>
  <files>src/gateway.rs</files>
  <action>
Modify `run_dispatch` signature to replace individual `rate_limiter: &RateLimiter` and `kill_switch: &KillSwitchConfig` parameters with `hot_config: SharedHotConfig`. Also add parameters: `metrics: Option<Arc<Metrics>>` and `schema_cache: &SchemaCache`.

IMPORTANT: Use `tokio::sync::RwLock` for hot_config (not std::sync::Mutex) since this is an async context. The RateLimiter's internal `std::sync::Mutex` stays unchanged -- only the outer container is RwLock.

For each tools/call request, the pipeline becomes (in order):
1. **Kill switch check** -- `let hc = hot_config.read().await;` then check `hc.kill_switch.disabled_tools` and `hc.kill_switch.disabled_backends`. Drop the read guard after checking.
2. **Rate limit check** -- `let hc = hot_config.read().await;` then `hc.rate_limiter.check(...)`. Can reuse the same read guard from step 1. On rate limit hit, also call `metrics.record_rate_limit_hit(tool)` if metrics is Some.
3. **RBAC check** -- unchanged (rbac_config is not hot-reloadable)
4. **Schema validation** (NEW) -- `schema_cache.validate(name, arguments)`. If Err, return JSON-RPC error with code `INVALID_PARAMS` (-32602) and message `"Invalid arguments for tool {name}: {errors.join("; ")}"`. Record audit entry with status "invalid_args". Record metrics with status "invalid_args".
5. **Circuit breaker check** -- unchanged
6. **Backend dispatch** -- unchanged

After each tools/call completes (success or error from backend), record metrics:
```rust
if let Some(ref m) = metrics {
    let status_str = if resp.error.is_some() { "error" } else { "success" };
    m.record_request(name, status_str, latency_secs);
}
```

Also record metrics for all rejection paths:
- Kill switch: `metrics.record_request(name, "killed", 0.0)`
- Rate limit: `metrics.record_request(name, "rate_limited", 0.0)` + `metrics.record_rate_limit_hit(name)`
- RBAC denied: `metrics.record_request(name, "denied", 0.0)`
- Circuit open: `metrics.record_request(name, "circuit_open", 0.0)`
- Invalid args: `metrics.record_request(name, "invalid_args", 0.0)`

Update the tools/list handler similarly: read kill_switch from hot_config.read().await instead of the direct reference.

Update existing unit/integration tests to use the new signature. For tests, create a SharedHotConfig with default values and pass `None` for metrics and a default SchemaCache (empty, validates nothing).
  </action>
  <verify>Run `cargo test` -- all existing tests pass with updated signatures. Run `cargo build` -- no warnings.</verify>
  <done>Gateway dispatch reads kill_switch and rate_limiter from SharedHotConfig (RwLock), validates schemas before dispatch, records all metrics. Pipeline order: kill switch -> rate limit -> RBAC -> schema validation -> circuit breaker -> dispatch.</done>
</task>

<task type="auto">
  <name>Task 2: Wire Metrics, SchemaCache, SharedHotConfig, and SIGHUP handler into main.rs</name>
  <files>src/main.rs</files>
  <action>
In main.rs, after config is loaded and catalog is built:

1. **Create Metrics:**
```rust
let metrics = Arc::new(sentinel_gateway::metrics::Metrics::new());
```

2. **Create SchemaCache from catalog:**
```rust
let schema_cache = sentinel_gateway::validation::SchemaCache::from_catalog(&catalog);
```

3. **Create SharedHotConfig:**
```rust
let hot_config = sentinel_gateway::config::hot::HotConfig::new(
    config.kill_switch,   // moved out of config
    RateLimiter::new(&config.rate_limits),
).shared();
```
Remove the standalone `let rate_limiter = ...` line since it's now inside HotConfig.

4. **Pass metrics to health server:**
Update the `run_health_server` call to pass `Some(metrics.clone())`. This requires the health server signature change from Plan 01.

5. **Add SIGHUP handler** to the signal handler spawn block. The existing signal handler cancels on SIGTERM/SIGINT. Add a separate spawn for SIGHUP that does NOT cancel but reloads config:
```rust
let config_path_reload = cli.config.clone();
let hot_config_reload = hot_config.clone();
tokio::spawn(async move {
    let mut sighup = signal(SignalKind::hangup()).expect("SIGHUP handler");
    loop {
        sighup.recv().await;
        tracing::info!("SIGHUP received, reloading config");
        match sentinel_gateway::config::hot::reload_hot_config(&config_path_reload) {
            Ok(new_hot) => {
                *hot_config_reload.write().await = new_hot;
                tracing::info!("Config reloaded successfully (kill_switch + rate_limits)");
            }
            Err(e) => {
                tracing::error!(error = %e, "Config reload failed, keeping previous config");
            }
        }
    }
});
```

6. **Update run_dispatch call** to pass `hot_config.clone()`, `Some(metrics.clone())`, and `&schema_cache` instead of `&rate_limiter` and `&config.kill_switch`.

7. **Wire backend health into metrics** in the health checker: after each health check cycle, call `metrics.set_backend_health(name, healthy)`. This can be done by passing `Some(metrics.clone())` to `health_checker` and adding a metrics parameter to the health checker function signature. OR simpler: after the health_map is updated in the health checker loop, read the map and update metrics. Choose the simpler approach -- pass metrics into health_checker and call `set_backend_health` after each check.

Update the health checker in `src/health/checker.rs` to accept `Option<Arc<Metrics>>` and call `metrics.set_backend_health()` after updating the health map. This is a minor signature change.

8. **Integration tests**: The existing integration tests in `tests/` will need their `run_dispatch` calls updated to the new signature. Create SharedHotConfig with default kill_switch/rate_limiter, pass None for metrics, pass empty SchemaCache. All existing tests should pass without behavior changes.
  </action>
  <verify>Run `cargo build` -- compiles without warnings. Run `cargo test` -- all tests pass (unit + integration). Manually verify: `cargo run -- --config sentinel.toml` starts, `curl http://127.0.0.1:9201/metrics` returns Prometheus text with sentinel_ metrics. Send SIGHUP with `kill -HUP <pid>` and verify "Config reloaded" in logs.</verify>
  <done>Main.rs creates Metrics, SchemaCache, and SharedHotConfig at startup. Health server exposes /metrics with live Prometheus data. SIGHUP reloads kill_switch and rate_limits atomically. All existing tests pass with updated signatures. Phase 9 is feature-complete.</done>
</task>

</tasks>

<verification>
- `cargo build` compiles without warnings
- `cargo test` -- all tests pass (unit + integration, should be ~130+)
- `curl http://127.0.0.1:9201/metrics` returns text with `sentinel_requests_total`, `sentinel_request_duration_seconds`, `sentinel_errors_total`, `sentinel_backend_healthy`, `sentinel_rate_limit_hits_total`
- SIGHUP reload: modify sentinel.toml kill_switch, send SIGHUP, verify change takes effect on next request
- Schema validation: send tools/call with invalid args, verify -32602 error with descriptive message
</verification>

<success_criteria>
- GET /metrics returns Prometheus-compatible metrics with all 5 sentinel_ metric families
- Tool call arguments are validated against cached JSON schemas (invalid args rejected with -32602)
- SIGHUP triggers config reload -- kill switch and rate limit changes take effect immediately
- Failed config reload logs error and keeps previous config
- All 6 Phase 9 requirements (OBS-01, OBS-02, OBS-03, OBS-04, CONFIG-03, KILL-03) are satisfied
- All existing tests pass with no behavior regressions
</success_criteria>

<output>
After completion, create `.planning/phases/09-observability-hot-reload/09-03-SUMMARY.md`
</output>
