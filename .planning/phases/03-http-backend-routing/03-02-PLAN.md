---
phase: 03-http-backend-routing
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - src/gateway.rs
  - src/main.rs
  - tests/gateway_integration_test.rs
autonomous: true
requirements: [ROUTE-01, PROTO-05]

must_haves:
  truths:
    - "A tools/call request for an n8n tool routes to the n8n backend via HttpBackend"
    - "A tools/call request for a sqlite tool routes to the sqlite backend via HttpBackend"
    - "The response from the backend has its JSON-RPC ID restored to the client's original ID"
    - "Unknown tool names return a JSON-RPC error with INVALID_PARAMS code"
    - "Backend communication errors return a JSON-RPC INTERNAL_ERROR to the client"
    - "Tool catalog is populated from real HTTP backends at startup (replacing stub catalog)"
  artifacts:
    - path: "src/gateway.rs"
      provides: "Dispatch loop with tools/call routing through HttpBackend + ID remapping"
      contains: "tools/call"
    - path: "src/main.rs"
      provides: "Startup wiring: build HTTP client, discover backends, populate catalog"
      contains: "build_http_client"
    - path: "tests/gateway_integration_test.rs"
      provides: "Integration tests for tools/call dispatch with mock backend responses"
  key_links:
    - from: "src/gateway.rs"
      to: "src/backend/http.rs"
      via: "Dispatch loop calls HttpBackend::send() for tools/call"
      pattern: "backend.*send"
    - from: "src/gateway.rs"
      to: "src/protocol/id_remapper.rs"
      via: "Remap ID before send, restore after receive"
      pattern: "id_remapper.*remap"
    - from: "src/gateway.rs"
      to: "src/catalog/mod.rs"
      via: "catalog.route(tool_name) to find backend"
      pattern: "catalog.*route"
    - from: "src/main.rs"
      to: "src/backend/http.rs"
      via: "Build shared client, create HttpBackend per config, discover tools"
      pattern: "build_http_client"
---

<objective>
Wire HttpBackend into the dispatch loop and main.rs startup: route tools/call through real HTTP backends with ID remapping, and replace stub catalog with live tool discovery.

Purpose: This completes Phase 3 -- the gateway can now route tool calls to real MCP backends (n8n, sqlite) over HTTP, parse their SSE responses, and return results to clients.
Output: Modified gateway.rs with tools/call routing, modified main.rs with backend discovery, updated integration tests.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-http-backend-routing/3-RESEARCH.md
@.planning/phases/03-http-backend-routing/03-01-SUMMARY.md
@src/gateway.rs
@src/main.rs
@src/catalog/mod.rs
@src/backend/mod.rs
@src/backend/http.rs
@src/protocol/id_remapper.rs
@src/protocol/jsonrpc.rs
@src/config/types.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire tools/call routing into dispatch loop and backend discovery into main.rs</name>
  <files>
    src/gateway.rs
    src/main.rs
  </files>
  <action>
**Modify `src/gateway.rs`:**

Change `run_dispatch` signature to accept a HashMap of backends and an IdRemapper:
```rust
pub async fn run_dispatch(
    mut rx: mpsc::Receiver<String>,
    tx: mpsc::Sender<String>,
    catalog: &ToolCatalog,
    backends: &HashMap<String, HttpBackend>,
    id_remapper: &IdRemapper,
) -> anyhow::Result<()>
```

Add a `"tools/call"` match arm in the dispatch loop (before the catch-all `method` arm):
1. Extract `params.name` as the tool name. If missing, return INVALID_PARAMS error.
2. Call `catalog.route(tool_name)` to find the backend name. If None, return INVALID_PARAMS error ("Unknown tool: {name}").
3. Remap the client's JSON-RPC ID via `id_remapper.remap(id, backend_name)`.
4. Build outbound JSON-RPC request with the remapped ID (as JsonRpcId::Number).
5. Serialize and send via `backends.get(backend_name).send(&body).await`.
6. On success: deserialize the response string as a JsonRpcResponse (add Deserialize to JsonRpcResponse), restore the original ID via `id_remapper.restore(gateway_id)`, send to client.
7. On error: restore the original ID, send INTERNAL_ERROR with the error message.
8. If backend not found in HashMap (should not happen if catalog is consistent), return INTERNAL_ERROR.

Add `Deserialize` derive to `JsonRpcResponse` in `src/protocol/jsonrpc.rs` (it currently only has Serialize).

**Modify `src/main.rs`:**

Replace the stub catalog with live backend discovery:
1. Call `build_http_client()` to create a shared reqwest::Client.
2. Filter `config.backends` to only `BackendType::Http` entries.
3. For each HTTP backend config:
   a. Create `HttpBackend::new(client.clone(), &backend_config)`
   b. Call `discover_tools(&backend)` (new async function, see below)
   c. Register discovered tools in the ToolCatalog via `catalog.register_backend(name, tools)`
   d. Store the HttpBackend in a `HashMap<String, HttpBackend>`
4. If discovery fails for a backend, log the error with tracing::error and continue (don't crash -- other backends may work).
5. Create an `IdRemapper::new()`.
6. Pass backends HashMap and id_remapper to `run_dispatch`.

Create a `discover_tools` async function (in `src/backend/http.rs` or a new `src/backend/discovery.rs`):
1. Send MCP `initialize` request (jsonrpc 2.0, method "initialize", params with protocolVersion "2025-03-26", capabilities {}, clientInfo {name: "sentinel-gateway", version: "0.1.0"}, id: 1).
2. Parse SSE response, log success.
3. Send `notifications/initialized` notification (no id field, method "notifications/initialized"). Fire and forget (ignore errors).
4. Send `tools/list` request (jsonrpc 2.0, method "tools/list", id: 2).
5. Parse response, extract `result.tools` as `Vec<Tool>` (use rmcp::model::Tool).
6. Return the tools vec.

Keep `create_stub_catalog()` in catalog/mod.rs (still useful for tests) but main.rs no longer calls it.

If no HTTP backends are configured (or all fail discovery), fall back to the stub catalog with a tracing::warn message. This ensures the binary always starts.
  </action>
  <verify>
`cargo build 2>&1 | tail -5` shows successful compilation. `cargo clippy 2>&1 | grep warning | wc -l` shows 0.
  </verify>
  <done>
Dispatch loop routes tools/call through HttpBackend with ID remapping. main.rs discovers tools from HTTP backends at startup. Binary compiles cleanly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Integration tests for tools/call dispatch with mock responses</name>
  <files>
    tests/gateway_integration_test.rs
  </files>
  <action>
Update existing integration tests in `tests/gateway_integration_test.rs` to pass the new `run_dispatch` signature (add empty backends HashMap and IdRemapper to all existing test calls so they continue to pass).

Add new test cases:

- `test_tools_call_unknown_tool` -- send tools/call with name "nonexistent" after initializing. Verify INVALID_PARAMS error response.
- `test_tools_call_missing_name` -- send tools/call with no name in params. Verify INVALID_PARAMS error response.
- `test_tools_call_routes_to_correct_backend` -- use the stub catalog and a mock backend (if feasible). Register a backend name in the HashMap. Verify the tool name correctly maps via catalog.route(). This can be a unit-style test that validates routing logic without needing a real HTTP server.

For tests that need a real HttpBackend, test the routing logic by verifying:
1. The catalog routes the tool to the expected backend name
2. The ID remapper produces a unique gateway ID and can restore the original
3. Error paths (backend not in HashMap) return INTERNAL_ERROR

Note: Full end-to-end tests against real n8n/sqlite backends are deferred to Phase 10 (deployment). These tests validate the dispatch logic using stubs/mocks.

Ensure all existing tests still pass with the updated run_dispatch signature.
  </action>
  <verify>
`cargo test 2>&1 | grep "test result"` shows all tests passing (existing + new). `cargo test --test gateway_integration_test 2>&1` shows specific gateway tests passing.
  </verify>
  <done>
All existing 54+ tests pass with updated signatures. New tests validate tools/call error paths (unknown tool, missing name) and routing logic. Total test count increases.
  </done>
</task>

</tasks>

<verification>
- `cargo build --release` compiles with no errors or warnings
- `cargo clippy` passes with no warnings
- `cargo test` runs all tests with 0 failures
- tools/call for a known tool routes to the correct backend via catalog.route()
- tools/call for an unknown tool returns INVALID_PARAMS error
- ID remapping is applied before sending to backend and restored on response
- main.rs discovers tools from HTTP backends (or falls back to stub catalog)
</verification>

<success_criteria>
- tools/call dispatches through HttpBackend with SSE parsing and ID remapping
- Backend discovery populates ToolCatalog from real HTTP backends at startup
- Error paths return proper JSON-RPC errors (INVALID_PARAMS, INTERNAL_ERROR)
- All tests pass (existing + new dispatch tests)
- Binary starts and runs with either real backends or stub catalog fallback
</success_criteria>

<output>
After completion, create `.planning/phases/03-http-backend-routing/03-02-SUMMARY.md`
</output>
