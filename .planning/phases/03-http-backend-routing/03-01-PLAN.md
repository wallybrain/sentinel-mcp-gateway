---
phase: 03-http-backend-routing
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Cargo.toml
  - src/lib.rs
  - src/backend/mod.rs
  - src/backend/http.rs
  - src/backend/sse.rs
  - src/backend/retry.rs
  - src/backend/error.rs
  - tests/backend_test.rs
autonomous: true
requirements: [ROUTE-03, ROUTE-04, PROTO-05]

must_haves:
  truths:
    - "HttpBackend can POST JSON-RPC to an HTTP endpoint and parse SSE responses"
    - "Transient errors (timeout, connection refused, 5xx) trigger automatic retry with exponential backoff and jitter"
    - "Non-retryable errors (4xx, invalid response) fail immediately without retry"
    - "SSE data: lines are correctly parsed into JSON-RPC response strings"
    - "Connection pooling is configured via shared reqwest::Client"
  artifacts:
    - path: "src/backend/mod.rs"
      provides: "Module re-exports for BackendError, HttpBackend, build_http_client"
    - path: "src/backend/http.rs"
      provides: "HttpBackend struct with send() method"
      min_lines: 50
    - path: "src/backend/sse.rs"
      provides: "SSE line parser extracting data: content"
      min_lines: 15
    - path: "src/backend/retry.rs"
      provides: "retry_with_backoff generic async function"
      min_lines: 25
    - path: "src/backend/error.rs"
      provides: "BackendError enum with is_retryable()"
      min_lines: 25
    - path: "tests/backend_test.rs"
      provides: "Unit tests for SSE parsing, retry logic, error classification"
      min_lines: 50
  key_links:
    - from: "src/backend/http.rs"
      to: "src/backend/sse.rs"
      via: "read_sse_response calls SSE parser"
      pattern: "parse_sse_data"
    - from: "src/backend/http.rs"
      to: "src/backend/retry.rs"
      via: "send() wraps POST in retry_with_backoff"
      pattern: "retry_with_backoff"
    - from: "src/backend/http.rs"
      to: "src/backend/error.rs"
      via: "All errors are BackendError variants"
      pattern: "BackendError"
---

<objective>
Build the HTTP backend module: HttpBackend struct that POSTs JSON-RPC to MCP backends, parses SSE responses, retries transient failures, and uses connection pooling.

Purpose: This is the core HTTP communication layer that Phase 3 Plan 02 will wire into the dispatch loop. Isolated module with no gateway dependencies, fully unit-testable.
Output: `src/backend/` module with HttpBackend, SSE parser, retry logic, and BackendError.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-http-backend-routing/3-RESEARCH.md
@.planning/phases/02-mcp-protocol-layer/02-02-SUMMARY.md
@src/config/types.rs
@src/protocol/jsonrpc.rs
@Cargo.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Backend module with HttpBackend, SSE parser, retry, and error types</name>
  <files>
    Cargo.toml
    src/lib.rs
    src/backend/mod.rs
    src/backend/error.rs
    src/backend/sse.rs
    src/backend/retry.rs
    src/backend/http.rs
  </files>
  <action>
Add reqwest, bytes, futures, and rand to Cargo.toml dependencies:
```
reqwest = { version = "0.13", default-features = false, features = ["rustls-tls", "json", "stream"] }
bytes = "1"
futures = "0.3"
rand = "0.9"
```

Create `src/backend/error.rs`:
- `BackendError` enum with variants: Request(reqwest::Error), HttpStatus(u16, String), Stream(reqwest::Error), NoDataInSse, InvalidResponse(String)
- Implement `Display` and `Error` via thiserror
- `is_retryable(&self) -> bool`: Request (timeout/connect only), HttpStatus (>= 500), Stream (yes), NoDataInSse/InvalidResponse (no)

Create `src/backend/sse.rs`:
- `parse_sse_data(raw: &str) -> Option<String>` -- iterate lines, find first non-empty `data:` line, return stripped content
- Handle edge cases: empty data lines, multiple data lines (return first), no data lines (return None)

Create `src/backend/retry.rs`:
- `retry_with_backoff<F, Fut, T>(max_retries: u32, operation: F) -> Result<T, BackendError>` where F: FnMut() -> Fut
- Base delay: 100ms * 2^attempt. Jitter: random 0..base/2. Use `rand::rng().random_range()`
- Log each retry attempt with tracing::warn (attempt number, delay, error)
- If max_retries is 0, execute once with no retry

Create `src/backend/http.rs`:
- `build_http_client() -> Result<Client, reqwest::Error>` -- tcp_nodelay(true), pool_max_idle_per_host(10), pool_idle_timeout(90s), connect_timeout(5s)
- `HttpBackend` struct with fields: client (reqwest::Client), url (String, always ending in /mcp), timeout (Duration), max_retries (u32)
- `HttpBackend::new(client: Client, config: &BackendConfig) -> Self` -- append /mcp to URL if not present, read timeout_secs and retries from config
- `HttpBackend::send(&self, json_rpc_body: &str) -> Result<String, BackendError>` -- wraps the POST in retry_with_backoff. Each attempt: POST to self.url with Content-Type application/json and Accept application/json, text/event-stream. Check response status. If SSE content-type, call read_sse_response. Otherwise return text directly.
- `HttpBackend::read_sse_response(response: reqwest::Response) -> Result<String, BackendError>` -- use bytes_stream() + futures::StreamExt::next() to accumulate chunks into BytesMut, then call parse_sse_data on the result. Return BackendError::NoDataInSse if no data line found.
- `HttpBackend::url(&self) -> &str` -- getter for logging

Create `src/backend/mod.rs`:
- Re-export: BackendError, HttpBackend, build_http_client

Add `pub mod backend;` to `src/lib.rs`.

Ensure `cargo build` compiles with zero warnings and `cargo clippy` passes.
  </action>
  <verify>
`cargo build 2>&1 | tail -5` shows successful compilation. `cargo clippy 2>&1 | grep warning | wc -l` shows 0.
  </verify>
  <done>
Backend module compiles cleanly with HttpBackend, SSE parser, retry logic, and BackendError -- all types exported from src/backend/mod.rs.
  </done>
</task>

<task type="auto">
  <name>Task 2: Unit tests for SSE parsing, error classification, and retry logic</name>
  <files>
    tests/backend_test.rs
  </files>
  <action>
Create `tests/backend_test.rs` with these test cases:

SSE parsing tests:
- `test_parse_sse_basic` -- input "event: message\ndata: {\"jsonrpc\":\"2.0\",\"id\":1}\n\n" returns the JSON string
- `test_parse_sse_no_data_line` -- input "event: message\n\n" returns None
- `test_parse_sse_empty_data` -- input "data: \n\n" returns None (empty data after trimming)
- `test_parse_sse_multiple_data_lines` -- returns first non-empty data line
- `test_parse_sse_with_whitespace` -- "data:  {\"result\":{}}\n" with extra space still works

Error classification tests:
- `test_backend_error_retryable_http_500` -- HttpStatus(500, _) is retryable
- `test_backend_error_not_retryable_http_400` -- HttpStatus(400, _) is NOT retryable
- `test_backend_error_not_retryable_no_data` -- NoDataInSse is NOT retryable
- `test_backend_error_not_retryable_invalid_response` -- InvalidResponse is NOT retryable

HttpBackend construction tests:
- `test_http_backend_appends_mcp_path` -- URL "http://localhost:3000" becomes "http://localhost:3000/mcp"
- `test_http_backend_preserves_mcp_path` -- URL "http://localhost:3000/mcp" stays unchanged
- `test_http_backend_strips_trailing_slash` -- URL "http://localhost:3000/" becomes "http://localhost:3000/mcp"

Build client test:
- `test_build_http_client` -- build_http_client() returns Ok

All tests use the public API only (no #[cfg(test)] internal access needed).
  </action>
  <verify>
`cargo test --test backend_test 2>&1 | tail -5` shows all tests passing. `cargo test 2>&1 | grep "test result"` shows all existing tests still pass.
  </verify>
  <done>
13+ tests covering SSE parsing, error classification, URL construction, and client building -- all passing alongside the existing 41 tests.
  </done>
</task>

</tasks>

<verification>
- `cargo build --release` compiles with no errors or warnings
- `cargo clippy` passes with no warnings
- `cargo test` runs all tests (existing 41 + new backend tests) with 0 failures
- `src/backend/` module exports HttpBackend, BackendError, build_http_client
</verification>

<success_criteria>
- HttpBackend struct can be instantiated with a BackendConfig and reqwest::Client
- SSE parser correctly extracts JSON-RPC data from SSE-formatted responses
- BackendError::is_retryable() correctly classifies transient vs permanent errors
- retry_with_backoff retries on transient errors with exponential delay + jitter
- All 54+ tests pass (41 existing + 13+ new)
</success_criteria>

<output>
After completion, create `.planning/phases/03-http-backend-routing/03-01-SUMMARY.md`
</output>
