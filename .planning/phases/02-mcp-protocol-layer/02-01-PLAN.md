---
phase: 02-mcp-protocol-layer
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Cargo.toml
  - src/lib.rs
  - src/protocol/mod.rs
  - src/protocol/mcp.rs
  - src/transport/mod.rs
  - src/transport/stdio.rs
  - tests/mcp_lifecycle_test.rs
autonomous: true
requirements: [PROTO-02, PROTO-06]

must_haves:
  truths:
    - "The gateway reads newline-delimited JSON-RPC messages from stdin"
    - "The gateway writes newline-delimited JSON-RPC responses to stdout"
    - "The gateway responds to an MCP initialize request with protocol version 2025-03-26 and tools capability"
    - "The gateway rejects non-initialize requests before initialization completes with error -32002"
    - "The gateway accepts notifications/initialized and transitions to Operational state"
    - "The gateway responds to ping in any state"
  artifacts:
    - path: "src/transport/stdio.rs"
      provides: "Async stdin reader and stdout writer tasks connected via bounded channels"
      min_lines: 40
    - path: "src/protocol/mcp.rs"
      provides: "MCP lifecycle state machine and initialize handler"
      min_lines: 60
      contains: "McpState"
    - path: "Cargo.toml"
      provides: "rmcp dependency added"
      contains: "rmcp"
  key_links:
    - from: "src/transport/stdio.rs"
      to: "tokio::io::stdin/stdout"
      via: "BufReader::read_line and BufWriter::write_all"
      pattern: "BufReader|BufWriter"
    - from: "src/protocol/mcp.rs"
      to: "rmcp::model"
      via: "InitializeResult, ServerCapabilities, ProtocolVersion"
      pattern: "rmcp::model"
---

<objective>
Add rmcp dependency, build the stdio transport layer (reader/writer tasks with bounded channels), and implement the MCP lifecycle state machine with initialize handshake handler.

Purpose: Establishes the two foundational layers -- how bytes flow in/out (transport) and how the MCP protocol state is managed (lifecycle). Plan 02 builds the dispatch loop and tool catalog on top of these.
Output: Compilable transport and protocol modules with unit tests proving state transitions and initialize response correctness.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-mcp-protocol-layer/2-RESEARCH.md
@.planning/phases/01-foundation-config/01-02-SUMMARY.md
@src/protocol/jsonrpc.rs
@src/protocol/id_remapper.rs
@src/protocol/mod.rs
@src/lib.rs
@Cargo.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add rmcp dependency and build stdio transport + MCP state machine</name>
  <files>
    Cargo.toml
    src/lib.rs
    src/protocol/mod.rs
    src/protocol/mcp.rs
    src/transport/mod.rs
    src/transport/stdio.rs
  </files>
  <action>
**1. Add rmcp to Cargo.toml:**
```toml
rmcp = { version = "=0.16.0", default-features = false }
```
Run `cargo check` to verify rmcp types are available. If rmcp feature flags cause issues (e.g., missing serde derives), try `features = ["serde"]` -- but start with no features per research.

**2. Create `src/transport/mod.rs`:**
Export `stdio` module.

**3. Create `src/transport/stdio.rs`:**
Two public async functions:
- `pub async fn stdio_reader(tx: mpsc::Sender<String>)` -- reads lines from `tokio::io::stdin()` via `BufReader::read_line()`. Trims trailing whitespace. Skips empty lines. Sends non-empty lines to channel. Breaks on EOF (0 bytes read) or channel closed. Logs errors to tracing at error level.
- `pub async fn stdio_writer(mut rx: mpsc::Receiver<String>)` -- reads from channel, writes each message + `\n` to `tokio::io::stdout()` via `BufWriter`. Calls `flush().await` after every message. Breaks on channel closed or write error.

Use `tokio::sync::mpsc::channel(64)` for bounded channels (documented in research). Import `tokio::io::{AsyncBufReadExt, AsyncWriteExt, BufReader, BufWriter}`.

IMPORTANT: Never use `println!` -- stdout is exclusively for the writer task. All logging goes to stderr via tracing.

**4. Create `src/protocol/mcp.rs`:**

MCP lifecycle state machine:
```rust
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum McpState {
    Created,
    Initializing,
    Operational,
    Closed,
}
```

Implement `McpState::can_accept_method(&self, method: &str) -> bool` per MCP spec:
- `Created`: only "initialize" and "ping"
- `Initializing`: only "notifications/initialized" and "ping"
- `Operational`: all methods accepted
- `Closed`: nothing accepted

Initialize handler function:
```rust
pub fn handle_initialize(params: Value) -> Result<Value, (i32, String)>
```
- Deserialize `params` into `rmcp::model::InitializeRequestParams` via `serde_json::from_value`. If deserialization fails, return `Err((INVALID_PARAMS, message))`.
- Build `InitializeResult` with:
  - `protocol_version: ProtocolVersion::V_2025_03_26`
  - `capabilities: ServerCapabilities::builder().enable_tools().build()`
  - `server_info: Implementation { name: "sentinel-gateway".into(), version: env!("CARGO_PKG_VERSION").into() }`
  - `instructions: Some("Sentinel Gateway - governed MCP tool access".into())`
- Serialize result to `serde_json::Value` and return `Ok(value)`.
- Log client info at `info` level (params.client_info.name and version).

NOTE on rmcp API: The research shows `ServerCapabilities::builder().enable_tools().build()`. If this builder API doesn't exist in rmcp 0.16.0, construct `ServerCapabilities` directly by setting `tools: Some(ToolsCapability::default())` or equivalent. Check rmcp docs. The key thing is the `tools` capability must be present in the response.

NOTE on rmcp imports: Use `rmcp::model::*` for types. If the module path is different (e.g., `rmcp::types::*`), adjust accordingly -- rmcp 0.16 is pre-1.0 and docs may not match exactly.

**5. Update `src/protocol/mod.rs`:**
Add `pub mod mcp;` and re-export key types.

**6. Update `src/lib.rs`:**
Add `pub mod transport;`

**7. Verify:** `cargo check` and `cargo build --release` compile with 0 errors, 0 warnings.
  </action>
  <verify>
`cargo build --release` succeeds with 0 errors and 0 warnings. `cargo doc --no-deps` generates docs for transport and mcp modules.
  </verify>
  <done>
stdio transport module exists with reader/writer functions. MCP state machine enum with can_accept_method exists. Initialize handler produces valid InitializeResult with protocol version 2025-03-26 and tools capability. rmcp dependency compiles cleanly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Unit tests for MCP state machine and initialize handler</name>
  <files>
    tests/mcp_lifecycle_test.rs
  </files>
  <action>
Create `tests/mcp_lifecycle_test.rs` with the following tests:

**State machine tests:**
1. `test_created_accepts_initialize` -- Created state accepts "initialize", returns true
2. `test_created_accepts_ping` -- Created state accepts "ping", returns true
3. `test_created_rejects_tools_list` -- Created state rejects "tools/list", returns false
4. `test_created_rejects_tools_call` -- Created state rejects "tools/call", returns false
5. `test_initializing_accepts_initialized_notification` -- Initializing accepts "notifications/initialized"
6. `test_initializing_rejects_initialize` -- Initializing rejects "initialize" (can't re-init)
7. `test_initializing_accepts_ping` -- Initializing accepts "ping"
8. `test_operational_accepts_all` -- Operational accepts "initialize", "tools/list", "tools/call", "ping", "notifications/initialized", arbitrary methods
9. `test_closed_rejects_all` -- Closed rejects everything

**Initialize handler tests:**
10. `test_initialize_returns_valid_response` -- Call handle_initialize with a valid InitializeRequestParams JSON value. Verify the result contains `protocolVersion` = "2025-03-26", `capabilities` has `tools` key, `serverInfo.name` = "sentinel-gateway".
11. `test_initialize_with_invalid_params` -- Call handle_initialize with `serde_json::json!({})` or malformed params. Verify it returns an error (Err variant) -- NOT a panic.

For test 10, construct the input as:
```rust
serde_json::json!({
    "protocolVersion": "2025-03-26",
    "capabilities": {},
    "clientInfo": {"name": "test-client", "version": "1.0.0"}
})
```

Then verify the output value has the correct structure. Use `result["protocolVersion"]` assertions on the serialized JSON to avoid coupling to rmcp's internal struct layout.

Run `cargo test` -- all tests must pass (existing 19 from Phase 1 + 11 new = 30 total).
  </action>
  <verify>
`cargo test` passes with 0 failures. At least 11 new tests in mcp_lifecycle_test.rs. Total test count is 30 (19 existing + 11 new).
  </verify>
  <done>
MCP state machine has 9 tests proving correct method gating per MCP spec. Initialize handler has 2 tests proving valid response structure and error handling. All 30 tests pass.
  </done>
</task>

</tasks>

<verification>
- `cargo build --release` compiles with 0 errors, 0 warnings
- `cargo test` passes all 30 tests (19 Phase 1 + 11 Phase 2 plan 01)
- `cargo clippy` produces no warnings
- `src/transport/stdio.rs` exists with reader and writer functions
- `src/protocol/mcp.rs` exists with McpState enum and handle_initialize function
- No `println!` calls anywhere in src/ (stdout is reserved for JSON-RPC)
</verification>

<success_criteria>
- rmcp 0.16.0 compiles as a dependency with types available
- stdio transport has async reader/writer connected via bounded mpsc channels
- MCP lifecycle state machine correctly gates methods by state
- Initialize handler returns spec-compliant response with protocol version 2025-03-26
- 30 total tests passing
</success_criteria>

<output>
After completion, create `.planning/phases/02-mcp-protocol-layer/02-01-SUMMARY.md`
</output>
