---
phase: 08-stdio-backend-management
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Cargo.toml
  - src/backend/stdio.rs
  - src/backend/mod.rs
  - src/backend/error.rs
autonomous: true
requirements: [STDIO-01, STDIO-04, STDIO-05]

must_haves:
  truths:
    - "A StdioBackend can spawn a child process with piped stdin/stdout in its own process group"
    - "Multiple concurrent JSON-RPC requests to the same StdioBackend are multiplexed via request ID correlation"
    - "A StdioBackend can kill its entire process group (not just direct child)"
    - "Requests that timeout are cleaned up from the pending map"
  artifacts:
    - path: "src/backend/stdio.rs"
      provides: "StdioBackend struct with spawn, send, stdout_reader, stdin_writer, kill_process_group"
      min_lines: 150
    - path: "src/backend/error.rs"
      provides: "BackendError with stdio-specific variants (ProcessExited, StdinClosed)"
      contains: "ProcessExited"
    - path: "Cargo.toml"
      provides: "nix dependency for killpg"
      contains: "nix"
  key_links:
    - from: "src/backend/stdio.rs"
      to: "tokio::process::Command"
      via: "process_group(0) spawn"
      pattern: "process_group\\(0\\)"
    - from: "src/backend/stdio.rs"
      to: "nix::sys::signal::killpg"
      via: "process group termination"
      pattern: "killpg"
    - from: "src/backend/stdio.rs"
      to: "pending HashMap"
      via: "oneshot channels for request-response correlation"
      pattern: "oneshot::Sender"
---

<objective>
Create the StdioBackend struct that spawns a child process, multiplexes concurrent JSON-RPC requests over its stdin/stdout using request ID correlation, and can terminate the entire process group.

Purpose: This is the foundation for stdio backend management -- the gateway's key differentiator. StdioBackend parallels HttpBackend with the same `send()` interface.
Output: `src/backend/stdio.rs` with StdioBackend, `nix` dependency added, BackendError extended with stdio variants.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-stdio-backend-management/08-RESEARCH.md
@src/backend/http.rs
@src/backend/mod.rs
@src/backend/error.rs
@src/config/types.rs
@Cargo.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add nix dependency and extend BackendError with stdio variants</name>
  <files>Cargo.toml, src/backend/error.rs</files>
  <action>
Add `nix` dependency to Cargo.toml with features `signal` and `process`:
```
nix = { version = "0.29", default-features = false, features = ["signal", "process"] }
```

Extend `BackendError` in `src/backend/error.rs` with two new variants:
- `ProcessExited(String)` -- child process exited unexpectedly (not retryable)
- `StdinClosed` -- stdin channel to child is closed (not retryable)

Update `is_retryable()` to return `false` for both new variants.
Update `Display` impl to format both new variants.
Update `Error::source()` to return `None` for both.
  </action>
  <verify>`cargo check` compiles with no errors or warnings.</verify>
  <done>Cargo.toml has nix dependency. BackendError has ProcessExited and StdinClosed variants that compile.</done>
</task>

<task type="auto">
  <name>Task 2: Implement StdioBackend with multiplexer and process group management</name>
  <files>src/backend/stdio.rs, src/backend/mod.rs</files>
  <action>
Create `src/backend/stdio.rs` with the following components:

**StdioBackend struct** (must be Clone):
```rust
pub struct StdioBackend {
    name: String,
    stdin_tx: mpsc::Sender<String>,
    pending: Arc<Mutex<HashMap<u64, oneshot::Sender<String>>>>,
    pid: Arc<AtomicU32>,  // Track PID for process group kill
    timeout: Duration,
}
```

Fields:
- `name: String` -- backend name for logging
- `stdin_tx: mpsc::Sender<String>` -- bounded channel (64) to write to child stdin
- `pending: Arc<std::sync::Mutex<HashMap<u64, oneshot::Sender<String>>>>` -- request-response correlation map (use std::sync::Mutex, not tokio -- matches project pattern from rate limiter, zero contention)
- `pid: Arc<AtomicU32>` -- current child PID, updated on restart, 0 means no active child
- `timeout: Duration` -- per-request timeout from BackendConfig

**`StdioBackend::spawn()` associated function:**
- Takes `&BackendConfig` and returns `(StdioBackend, JoinHandle<()>, JoinHandle<()>)` -- the backend plus the stdin_writer and stdout_reader task handles
- Spawn child via `tokio::process::Command::new(config.command.as_deref().unwrap())`
- Set `.args(&config.args)`, individual `.env(k, v)` calls for each entry in `config.env` (preserves parent env inheritance -- do NOT use `.envs()` which replaces inherited env)
- Set `.stdin(Stdio::piped()).stdout(Stdio::piped()).stderr(Stdio::piped())`
- Set `.process_group(0)` and `.kill_on_drop(false)` (we manage lifecycle)
- Store child PID in `pid: Arc<AtomicU32>`
- Take ownership of child stdin/stdout handles
- Spawn `stdin_writer` task: reads from `mpsc::Receiver<String>`, writes each line to child stdin with newline delimiter, flushes after each write
- Spawn `stdout_reader` task: uses `tokio::io::BufReader::read_line()` on child stdout, parses each line as JSON to extract `id` field (as u64), looks up and removes from pending map, sends response via oneshot. Handle: no `id` field (log at debug, skip), unknown `id` (log at debug, drop), empty lines (skip), EOF (break -- process exited)
- Return stderr handle attached to child (for future logging -- do not spawn reader yet, just pipe it)

**`StdioBackend::send()` method:**
- Signature: `pub async fn send(&self, json_rpc_body: &str) -> Result<String, BackendError>`
- Parse request to extract `id` as u64 from the JSON
- Create `oneshot::channel()` for this request
- Insert into pending map
- Send body + newline to stdin_tx, map error to `BackendError::StdinClosed`
- Await response with `tokio::time::timeout(self.timeout, resp_rx)`
- On timeout: remove from pending map, return `BackendError::InvalidResponse("request timed out")`
- On channel drop: return `BackendError::ProcessExited`

**`StdioBackend::name()` method:**
- Returns `&str` (backend name for logging, parallels `HttpBackend::url()`)

**`kill_process_group(pid: u32)` free function:**
- Use `nix::sys::signal::killpg(Pid::from_raw(pid as i32), Signal::SIGTERM)`
- Handle `Errno::ESRCH` gracefully (process already dead, log at debug)
- Log other errors at warn level

**`drain_pending()` free function:**
- Takes `&Arc<Mutex<HashMap<u64, oneshot::Sender<String>>>>>`
- Locks, drains all entries, drops the senders (receivers will get RecvError)

Update `src/backend/mod.rs`:
- Add `pub mod stdio;`
- Add `pub use stdio::StdioBackend;` to exports

Write unit tests in `src/backend/stdio.rs` (#[cfg(test)] module):
1. Test `kill_process_group` with a real spawned `sleep` process -- spawn sleep 60 in new process group, call kill_process_group, verify child.wait() completes
2. Test `drain_pending` empties the map and drops senders
3. Test `StdioBackend::spawn` + `send` with a simple echo-like child process: spawn `cat` (which echoes stdin to stdout), send a JSON-RPC request, verify the response comes back. Use a short timeout.
  </action>
  <verify>`cargo test --lib backend::stdio` passes all tests. `cargo check` has no warnings.</verify>
  <done>StdioBackend spawns child processes in their own process group, multiplexes requests via ID correlation with oneshot channels, and can kill the entire process group. At least 3 unit tests pass.</done>
</task>

</tasks>

<verification>
- `cargo check` compiles with no errors or warnings
- `cargo test --lib backend::stdio` passes all unit tests
- `StdioBackend::send()` has same interface shape as `HttpBackend::send()` (takes `&str`, returns `Result<String, BackendError>`)
</verification>

<success_criteria>
- StdioBackend struct exists with spawn(), send(), name(), kill_process_group(), drain_pending()
- Request multiplexing works via pending HashMap + oneshot channels
- Process group spawn (process_group(0)) and kill (killpg) are implemented
- Unit tests prove spawn/send/kill work with real child processes
</success_criteria>

<output>
After completion, create `.planning/phases/08-stdio-backend-management/08-01-SUMMARY.md`
</output>
